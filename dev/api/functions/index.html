<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions and Macros · Dagger.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/api/functions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Dagger.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../dtable/">Distributed Table</a></li><li><a class="tocitem" href="../../processors/">Processors</a></li><li><a class="tocitem" href="../../scopes/">Scopes</a></li><li><a class="tocitem" href="../../mutation/">Mutation and Shards</a></li><li><a class="tocitem" href="../../dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="../../logging/">Logging and Graphing</a></li><li><a class="tocitem" href="../../scheduler-visualization/">Scheduler Visualization</a></li><li><a class="tocitem" href="../../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../../checkpointing/">Checkpointing</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions and Macros</a><ul class="internal"><li><a class="tocitem" href="#General-Functions"><span>General Functions</span></a></li><li><a class="tocitem" href="#Table-Functions"><span>Table Functions</span></a></li><li><a class="tocitem" href="#Array-Functions"><span>Array Functions</span></a></li><li><a class="tocitem" href="#Processor-Functions"><span>Processor Functions</span></a></li><li><a class="tocitem" href="#Shard-Functions"><span>Shard Functions</span></a></li><li><a class="tocitem" href="#Context-Functions"><span>Context Functions</span></a></li><li><a class="tocitem" href="#Logging-Functions"><span>Logging Functions</span></a></li><li><a class="tocitem" href="#Thunk-Execution-Environment-Functions"><span>Thunk Execution Environment Functions</span></a></li><li><a class="tocitem" href="#File-IO-Functions"><span>File IO Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Macros-API"><span>Macros API</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../scheduler-internals/">Scheduler Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Functions and Macros</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions and Macros</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/api/functions.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><ul><li><a href="#Base.fetch"><code>Base.fetch</code></a></li><li><a href="#Base.filter"><code>Base.filter</code></a></li><li><a href="#Base.getindex"><code>Base.getindex</code></a></li><li><a href="#Base.keys"><code>Base.keys</code></a></li><li><a href="#Base.map"><code>Base.map</code></a></li><li><a href="#Base.reduce"><code>Base.reduce</code></a></li><li><a href="#Base.view"><code>Base.view</code></a></li><li><a href="#Base.wait"><code>Base.wait</code></a></li><li><a href="#Dagger.Sch.add_thunk!"><code>Dagger.Sch.add_thunk!</code></a></li><li><a href="#Dagger.Sch.exec!"><code>Dagger.Sch.exec!</code></a></li><li><a href="#Dagger.Sch.get_dag_ids"><code>Dagger.Sch.get_dag_ids</code></a></li><li><a href="#Dagger.Sch.halt!"><code>Dagger.Sch.halt!</code></a></li><li><a href="#Dagger.Sch.sch_handle"><code>Dagger.Sch.sch_handle</code></a></li><li><a href="#Dagger.addprocs!"><code>Dagger.addprocs!</code></a></li><li><a href="#Dagger.alignfirst"><code>Dagger.alignfirst</code></a></li><li><a href="#Dagger.capacity"><code>Dagger.capacity</code></a></li><li><a href="#Dagger.compute"><code>Dagger.compute</code></a></li><li><a href="#Dagger.default_enabled"><code>Dagger.default_enabled</code></a></li><li><a href="#Dagger.delayed"><code>Dagger.delayed</code></a></li><li><a href="#Dagger.dependents"><code>Dagger.dependents</code></a></li><li><a href="#Dagger.domain"><code>Dagger.domain</code></a></li><li><a href="#Dagger.execute!"><code>Dagger.execute!</code></a></li><li><a href="#Dagger.get_logs!"><code>Dagger.get_logs!</code></a></li><li><a href="#Dagger.get_parent"><code>Dagger.get_parent</code></a></li><li><a href="#Dagger.get_processors"><code>Dagger.get_processors</code></a></li><li><a href="#Dagger.get_tls"><code>Dagger.get_tls</code></a></li><li><a href="#Dagger.groupby"><code>Dagger.groupby</code></a></li><li><a href="#Dagger.in_thunk"><code>Dagger.in_thunk</code></a></li><li><a href="#Dagger.iscompatible"><code>Dagger.iscompatible</code></a></li><li><a href="#Dagger.load"><code>Dagger.load</code></a></li><li><a href="#Dagger.move"><code>Dagger.move</code></a></li><li><a href="#Dagger.noffspring"><code>Dagger.noffspring</code></a></li><li><a href="#Dagger.order"><code>Dagger.order</code></a></li><li><a href="#Dagger.rmprocs!"><code>Dagger.rmprocs!</code></a></li><li><a href="#Dagger.save"><code>Dagger.save</code></a></li><li><a href="#Dagger.set_tls!"><code>Dagger.set_tls!</code></a></li><li><a href="#Dagger.spawn"><code>Dagger.spawn</code></a></li><li><a href="#Dagger.tabletype"><code>Dagger.tabletype</code></a></li><li><a href="#Dagger.tabletype!"><code>Dagger.tabletype!</code></a></li><li><a href="#Dagger.thunk_processor"><code>Dagger.thunk_processor</code></a></li><li><a href="#Dagger.tochunk"><code>Dagger.tochunk</code></a></li><li><a href="#Dagger.treereduce"><code>Dagger.treereduce</code></a></li><li><a href="#Dagger.trim"><code>Dagger.trim</code></a></li><li><a href="#Dagger.trim!"><code>Dagger.trim!</code></a></li><li><a href="#DataAPI.innerjoin"><code>DataAPI.innerjoin</code></a></li><li><a href="#DataAPI.leftjoin"><code>DataAPI.leftjoin</code></a></li><li><a href="#Dagger.@par"><code>Dagger.@par</code></a></li><li><a href="#Dagger.@spawn"><code>Dagger.@spawn</code></a></li></ul><h2 id="General-Functions"><a class="docs-heading-anchor" href="#General-Functions">General Functions</a><a id="General-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#General-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Dagger.delayed" href="#Dagger.delayed"><code>Dagger.delayed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delayed(f; kwargs...)(args...)</code></pre><p>Creates a <a href="../types/#Dagger.Thunk"><code>Thunk</code></a> object which can be executed later, which will call <code>f</code> with <code>args</code>. <code>kwargs</code> controls various properties of the resulting <code>Thunk</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/thunk.jl#LL128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.spawn" href="#Dagger.spawn"><code>Dagger.spawn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spawn(f, args...; kwargs...) -&gt; EagerThunk</code></pre><p>Spawns a task with <code>f</code> as the function and <code>args</code> as the arguments, returning an <code>EagerThunk</code>. Uses a scheduler running in the background to execute code.</p><p>Note that <code>kwargs</code> are passed to the <code>Thunk</code> constructor, and are documented in its docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/thunk.jl#LL251-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.tochunk" href="#Dagger.tochunk"><code>Dagger.tochunk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tochunk(x, proc; persist=false, cache=false) -&gt; Chunk</code></pre><p>Create a chunk from sequential object <code>x</code> which resides on <code>proc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/chunks.jl#LL245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.domain" href="#Dagger.domain"><code>Dagger.domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">domain(x::T)</code></pre><p>Returns metadata about <code>x</code>. This metadata will be in the <code>domain</code> field of a Chunk object when an object of type <code>T</code> is created as the result of evaluating a Thunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/chunks.jl#LL7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.compute" href="#Dagger.compute"><code>Dagger.compute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute(ctx::Context, d::Thunk; options=nothing) -&gt; Chunk</code></pre><p>Compute a Thunk - creates the DAG, assigns ranks to nodes for tie breaking and runs the scheduler with the specified options. Returns a Chunk which references the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/compute.jl#LL20-L26">source</a></section><section><div><pre><code class="nohighlight hljs">compute(ctx::Context, x::DArray; persist=true, options=nothing)</code></pre><p>A <code>DArray</code> object may contain a thunk in it, in which case we first turn it into a <code>Thunk</code> and then compute it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/array/darray.jl#LL243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.dependents" href="#Dagger.dependents"><code>Dagger.dependents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dependents(node::Thunk) -&gt; Dict{Union{Thunk,Chunk}, Set{Thunk}}</code></pre><p>Find the set of direct dependents for each task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/compute.jl#LL84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.noffspring" href="#Dagger.noffspring"><code>Dagger.noffspring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">noffspring(dpents::Dict{Union{Thunk,Chunk}, Set{Thunk}}) -&gt; Dict{Thunk, Int}</code></pre><p>Recursively find the number of tasks dependent on each task in the DAG. Takes a Dict as returned by <a href="#Dagger.dependents"><code>dependents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/compute.jl#LL114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.order" href="#Dagger.order"><code>Dagger.order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">order(node::Thunk, ndeps) -&gt; Dict{Thunk,Int}</code></pre><p>Given a root node of the DAG, calculates a total order for tie-breaking.</p><ul><li>Root node gets score 1,</li><li>rest of the nodes are explored in DFS fashion but chunks of each node are explored in order of <code>noffspring</code>, i.e. total number of tasks depending on the result of the said node.</li></ul><p>Args:</p><ul><li>node: root node</li><li>ndeps: result of <a href="#Dagger.noffspring"><code>noffspring</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/compute.jl#LL144-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.treereduce" href="#Dagger.treereduce"><code>Dagger.treereduce</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Tree reduce</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/lib/util.jl#LL102-L104">source</a></section></article><h2 id="Table-Functions"><a class="docs-heading-anchor" href="#Table-Functions">Table Functions</a><a id="Table-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Table-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Dagger.tabletype" href="#Dagger.tabletype"><code>Dagger.tabletype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tabletype(d::DTable)</code></pre><p>Provides the type of the underlying table partition. Uses the cached tabletype if available.</p><p>In case the tabletype cannot be obtained the default return value is <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/dtable.jl#LL145-L152">source</a></section><section><div><pre><code class="nohighlight hljs">tabletype(gd::GDTable)</code></pre><p>Provides the type of the underlying table partition. Uses the cached tabletype if available.</p><p>In case the tabletype cannot be obtained the default return value is <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/gdtable.jl#LL113-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.tabletype!" href="#Dagger.tabletype!"><code>Dagger.tabletype!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tabletype!(d::DTable)</code></pre><p>Provides the type of the underlying table partition and caches it in <code>d</code>.</p><p>In case the tabletype cannot be obtained the default return value is <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/dtable.jl#LL136-L142">source</a></section><section><div><pre><code class="nohighlight hljs">tabletype!(gd::GDTable)</code></pre><p>Provides the type of the underlying table partition and caches it in <code>gd</code>.</p><p>In case the tabletype cannot be obtained the default return value is <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/gdtable.jl#LL103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.trim" href="#Dagger.trim"><code>Dagger.trim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trim(d::DTable) -&gt; DTable</code></pre><p>Returns <code>d</code> with empty chunks removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/dtable.jl#LL183-L187">source</a></section><section><div><pre><code class="nohighlight hljs">trim(gd::GDTable) -&gt; GDTable</code></pre><p>Returns <code>gd</code> with empty chunks and keys removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/gdtable.jl#LL95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.trim!" href="#Dagger.trim!"><code>Dagger.trim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trim!(d::DTable) -&gt; DTable</code></pre><p>Removes empty chunks from <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/dtable.jl#LL172-L176">source</a></section><section><div><pre><code class="nohighlight hljs">trim!(gd::GDTable) -&gt; GDTable</code></pre><p>Removes empty chunks from <code>gd</code> and unused keys from its index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/gdtable.jl#LL60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map" href="#Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">map(f, d::DTable) -&gt; DTable</code></pre><p>Applies <code>f</code> to each row of <code>d</code>. The applied function needs to return a <code>Tables.Row</code> compatible object (e.g. <code>NamedTuple</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; d = DTable((a = [1, 2, 3], b = [1, 1, 1]), 2);

julia&gt; m = map(x -&gt; (r = x.a + x.b,), d)
DTable with 2 partitions
Tabletype: NamedTuple

julia&gt; fetch(m)
(r = [2, 3, 4],)

julia&gt; m = map(x -&gt; (r1 = x.a + x.b, r2 = x.a - x.b), d)
DTable with 2 partitions
Tabletype: NamedTuple

julia&gt; fetch(m)
(r1 = [2, 3, 4], r2 = [0, 1, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/operations.jl#LL3-L27">source</a></section><section><div><pre><code class="nohighlight hljs">map(f, gd::GDTable) -&gt; GDTable</code></pre><p>Applies <code>f</code> to each row of <code>gd</code>. The applied function needs to return a <code>Tables.Row</code> compatible object (e.g. <code>NamedTuple</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = Dagger.groupby(DTable((a=repeat(&#39;a&#39;:&#39;c&#39;, inner=2),b=1:6), 2), :a)
GDTable with 3 partitions and 3 keys
Tabletype: NamedTuple
Grouped by: [:a]

julia&gt; m = map(r -&gt; (a = r.a, b = r.b, c = r.a + r.b), g)
GDTable with 3 partitions and 3 keys
Tabletype: NamedTuple
Grouped by: [:a]

julia&gt; fetch(m)
(a = [&#39;a&#39;, &#39;a&#39;, &#39;c&#39;, &#39;c&#39;, &#39;b&#39;, &#39;b&#39;], b = [1, 2, 5, 6, 3, 4], c = [&#39;b&#39;, &#39;c&#39;, &#39;h&#39;, &#39;i&#39;, &#39;e&#39;, &#39;f&#39;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/operations.jl#LL42-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter(f, d::DTable) -&gt; DTable</code></pre><p>Filter <code>d</code> using <code>f</code>. Returns a filtered <code>DTable</code> that can be processed further.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; d = DTable((a = [1, 2, 3], b = [1, 1, 1]), 2);

julia&gt; f = filter(x -&gt; x.a &lt; 3, d)
DTable with 2 partitions
Tabletype: NamedTuple

julia&gt; fetch(f)
(a = [1, 2], b = [1, 1])

julia&gt; f = filter(x -&gt; (x.a &lt; 3) .&amp; (x.b &gt; 0), d)
DTable with 2 partitions
Tabletype: NamedTuple

julia&gt; fetch(f)
(a = [1, 2], b = [1, 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/operations.jl#LL189-L213">source</a></section><section><div><pre><code class="nohighlight hljs">filter(f, gd::GDTable) -&gt; GDTable</code></pre><p>Filter &#39;gd&#39; using &#39;f&#39;, returning a filtered <code>GDTable</code>. Calling <code>trim!</code> on a filtered <code>GDTable</code> will clean up the empty keys and partitions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = Dagger.groupby(DTable((a=repeat(&#39;a&#39;:&#39;d&#39;, inner=2),b=1:8), 2), :a)
GDTable with 4 partitions and 4 keys
Tabletype: NamedTuple
Grouped by: [:a]

julia&gt; f = filter(x -&gt; x.a ∈ [&#39;a&#39;, &#39;b&#39;], g)
GDTable with 4 partitions and 4 keys
Tabletype: NamedTuple
Grouped by: [:a]

julia&gt; fetch(f)
(a = [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;], b = [1, 2, 3, 4])

julia&gt; trim!(f)
GDTable with 2 partitions and 2 keys
Tabletype: NamedTuple
Grouped by: [:a]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/operations.jl#LL223-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce" href="#Base.reduce"><code>Base.reduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reduce(f, d::DTable; cols=nothing, [init]) -&gt; NamedTuple</code></pre><p>Reduces <code>d</code> using function <code>f</code> applied on all columns of the DTable.</p><p>By providing the kwarg <code>cols</code> as a <code>Vector{Symbol}</code> object it&#39;s possible to restrict the reduction to the specified columns. The reduced values are provided in a NamedTuple under names of reduced columns.</p><p>For the <code>init</code> kwarg please refer to <code>Base.reduce</code> documentation, as it follows the same principles.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; d = DTable((a = [1, 2, 3], b = [1, 1, 1]), 2);

julia&gt; r1 = reduce(+, d)
EagerThunk (running)

julia&gt; fetch(r1)
(a = 6, b = 3)

julia&gt; r2 = reduce(*, d, cols=[:a])
EagerThunk (running)

julia&gt; fetch(r2)
(a = 6,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/operations.jl#LL69-L97">source</a></section><section><div><pre><code class="nohighlight hljs">reduce(f, gd::GDTable; cols=nothing, prefix=&quot;result_&quot;, [init]) -&gt; EagerThunk -&gt; NamedTuple</code></pre><p>Reduces <code>gd</code> using function <code>f</code> applied on all columns of the DTable. Returns results per group in columns with names prefixed with the <code>prefix</code> kwarg. For more information on kwargs see <code>reduce(f, d::DTable)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; g = Dagger.groupby(DTable((a=repeat(&#39;a&#39;:&#39;d&#39;, inner=2),b=1:8), 2), :a)
GDTable with 4 partitions and 4 keys
Tabletype: NamedTuple
Grouped by: [:a]

julia&gt; fetch(reduce(*, g))
(a = [&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;b&#39;], result_a = [&quot;aa&quot;, &quot;cc&quot;, &quot;dd&quot;, &quot;bb&quot;], result_b = [2, 30, 56, 12])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/operations.jl#LL141-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.groupby" href="#Dagger.groupby"><code>Dagger.groupby</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">groupby(d::DTable, col::Symbol; merge=true, chunksize=0) -&gt; GDTable</code></pre><p>Groups <code>d</code> by distinct values of column <code>col</code>.</p><p>The process of grouping can be affected by providing kwargs <code>merge</code> and <code>chunksize</code>. By default all the chunks belonging to a single key will be merged into a single partition. Providing a positive value in <code>chunksize</code> will attempt to merge the smaller partitions into partitions not bigger than <code>chunksize</code>. Please note that partitions bigger than <code>chunksize</code> will not be split into partitions of <code>chunksize</code>. Merging can be disabled completely by providing <code>merge=false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; d = DTable((a=shuffle(repeat(&#39;a&#39;:&#39;d&#39;, inner=4, outer=4)),), 4)
DTable with 16 partitions
Tabletype: NamedTuple

julia&gt; Dagger.groupby(d, :a)
GDTable with 4 partitions and 4 keys
Tabletype: NamedTuple
Grouped by: [:a]

julia&gt; Dagger.groupby(d, :a, chunksize=3)
GDTable with 24 partitions and 4 keys
Tabletype: NamedTuple
Grouped by: [:a]

julia&gt; Dagger.groupby(d, :a, merge=false)
GDTable with 42 partitions and 4 keys
Tabletype: NamedTuple
Grouped by: [:a]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/groupby.jl#LL1-L34">source</a></section><section><div><pre><code class="nohighlight hljs">groupby(d::DTable, cols::Vector{Symbol}; merge=true, chunksize=0)</code></pre><p>Groups the <code>d</code> by distinct values of columns <code>cols</code>. The key is constructed by creating a NamedTuple from each row based on <code>cols</code> provided.</p><p>For kwargs usage details see <code>groupby(d::DTable, col::Symbol)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; d = DTable((a=shuffle(repeat(&#39;a&#39;:&#39;d&#39;, inner=4, outer=4)),b=repeat(1:4, 16)), 4)
DTable with 16 partitions
Tabletype: NamedTuple

julia&gt; Dagger.groupby(d, [:a,:b])
GDTable with 16 partitions and 16 keys
Tabletype: NamedTuple
Grouped by: [:a, :b]

julia&gt; Dagger.groupby(d, [:a,:b], chunksize=3)
GDTable with 27 partitions and 16 keys
Tabletype: NamedTuple
Grouped by: [:a, :b]

julia&gt; Dagger.groupby(d, [:a,:b], merge=false)
GDTable with 64 partitions and 16 keys
Tabletype: NamedTuple
Grouped by: [:a, :b]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/groupby.jl#LL41-L70">source</a></section><section><div><pre><code class="nohighlight hljs">groupby(d::DTable, f::Function; merge=true, chunksize=0)</code></pre><p>Groups <code>d</code> by the distinct set of keys created by applying <code>f</code> to each row in <code>d</code>.</p><p>For kwargs usage details see <code>groupby(d::DTable, col::Symbol)</code></p><pre><code class="language-julia hljs">julia&gt; d = DTable((a=shuffle(repeat(&#39;a&#39;:&#39;d&#39;, inner=4, outer=4)),b=repeat(1:4, 16)), 4)
DTable with 16 partitions
Tabletype: NamedTuple

julia&gt; function group_fun(row)
           row.a + row.b
       end
group_fun (generic function with 1 method)

julia&gt; Dagger.groupby(d, group_fun)
GDTable with 7 partitions and 7 keys
Tabletype: NamedTuple
Grouped by: group_fun

julia&gt; Dagger.groupby(d, row -&gt; row.a + row.b, chunksize=3)
GDTable with 25 partitions and 7 keys
Tabletype: NamedTuple
Grouped by: group_fun

julia&gt; Dagger.groupby(d, row -&gt; row.a + row.b, merge=false)
GDTable with 52 partitions and 7 keys
Tabletype: NamedTuple
Grouped by: group_fun</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/groupby.jl#LL77-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.leftjoin" href="#DataAPI.leftjoin"><code>DataAPI.leftjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leftjoin(d1::DTable, d2; on=nothing, l_sorted=false, r_sorted=false, r_unique=false, lookup=nothing)</code></pre><p>Perform a left join of <code>d1</code> with any <code>Tables.jl</code> compatible table type. Returns a <code>DTable</code> with the result.</p><p>If the underlying table type happens to have a <code>leftjoin</code> implementation and none of the below <code>DTable</code> related kwargs will be provided the specialized function will be used. A good example of that is calling <code>leftjoin</code> on a <code>DTable</code> with a <code>DataFrame</code> underlying type and a <code>d2</code> of <code>DataFrame</code> type.</p><p><strong>Keyword arguments</strong></p><ul><li><code>on</code>: Column symbols to join on. Can be provided as a symbol or a pair of symbols in case the column names differ. For joins on multiple columns a vector of the previously mentioned can be provided.</li><li><code>l_sorted</code>: To indicate the left table is sorted - only useful if the <code>r_sorted</code> is set to <code>true</code> as well.</li><li><code>r_sorted</code>: To indicate the right table is sorted.</li><li><code>r_unique</code>: To indicate the right table only contains unique keys.</li><li><code>lookup</code>: To provide a dict-like structure that will allow for direct matching of inner rows. The structure needs to contain keys in form of a <code>Tuple</code> and values in form of type <code>Vector{UInt}</code> containing the related row indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/join_interface.jl#LL14-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.innerjoin" href="#DataAPI.innerjoin"><code>DataAPI.innerjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">innerjoin(d1::DTable, d2; on=nothing, l_sorted=false, r_sorted=false, r_unique=false, lookup=nothing)</code></pre><p>Perform an inner join of <code>d1</code> with any <code>Tables.jl</code> compatible table type. Returns a <code>DTable</code> with the result.</p><p>If the underlying table type happens to have a <code>innerjoin</code> implementation and none of the below <code>DTable</code> related kwargs will be provided the specialized function will be used. A good example of that is calling <code>innerjoin</code> on a <code>DTable</code> with a <code>DataFrame</code> underlying type and a <code>d2</code> of <code>DataFrame</code> type.</p><p><strong>Keyword arguments</strong></p><ul><li><code>on</code>: Column symbols to join on. Can be provided as a symbol or a pair of symbols in case the column names differ. For joins on multiple columns a vector of the previously mentioned can be provided.</li><li><code>l_sorted</code>: To indicate the left table is sorted - only useful if the <code>r_sorted</code> is set to <code>true</code> as well.</li><li><code>r_sorted</code>: To indicate the right table is sorted.</li><li><code>r_unique</code>: To indicate the right table only contains unique keys.</li><li><code>lookup</code>: To provide a dict-like structure that will allow for direct matching of inner rows. The structure needs to contain keys in form of a <code>Tuple</code> and values in form of type <code>Vector{UInt}</code> containing the related row indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/join_interface.jl#LL60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">keys(gd::GDTable) -&gt; KeySet</code></pre><p>Returns the keys that <code>gd</code> is grouped by.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/gdtable.jl#LL35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getindex(gdt::GDTable, key) -&gt; DTable</code></pre><p>Retrieves a <code>DTable</code> from <code>gdt</code> with rows belonging to the provided grouping key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/gdtable.jl#LL136-L140">source</a></section></article><h2 id="Array-Functions"><a class="docs-heading-anchor" href="#Array-Functions">Array Functions</a><a id="Array-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Dagger.alignfirst" href="#Dagger.alignfirst"><code>Dagger.alignfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alignfirst(a) -&gt; ArrayDomain</code></pre><p>Make a subdomain a standalone domain.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alignfirst(ArrayDomain(11:25, 21:100))
ArrayDomain((1:15), (1:80))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/array/darray.jl#LL46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.view" href="#Base.view"><code>Base.view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">view(c::DArray, d)</code></pre><p>A <code>view</code> of a <code>DArray</code> chunk returns a <code>DArray</code> of <code>Thunk</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/array/darray.jl#LL183-L187">source</a></section></article><h2 id="Processor-Functions"><a class="docs-heading-anchor" href="#Processor-Functions">Processor Functions</a><a id="Processor-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Processor-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Dagger.execute!" href="#Dagger.execute!"><code>Dagger.execute!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">execute!(proc::Processor, f, args...) -&gt; Any</code></pre><p>Executes the function <code>f</code> with arguments <code>args</code> on processor <code>proc</code>. This function can be overloaded by <code>Processor</code> subtypes to allow executing function calls differently than normal Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.iscompatible" href="#Dagger.iscompatible"><code>Dagger.iscompatible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iscompatible(proc::Processor, opts, f, Targs...) -&gt; Bool</code></pre><p>Indicates whether <code>proc</code> can execute <code>f</code> over <code>Targs</code> given <code>opts</code>. <code>Processor</code> subtypes should overload this function to return <code>true</code> if and only if it is essentially guaranteed that <code>f(::Targs...)</code> is supported. Additionally, <code>iscompatible_func</code> and <code>iscompatible_arg</code> can be overriden to determine compatibility of <code>f</code> and <code>Targs</code> individually. The default implementation returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.default_enabled" href="#Dagger.default_enabled"><code>Dagger.default_enabled</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_enabled(proc::Processor) -&gt; Bool</code></pre><p>Returns whether processor <code>proc</code> is enabled by default (opt-out). <code>Processor</code> subtypes can override this function to make themselves opt-in (default returns <code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.get_processors" href="#Dagger.get_processors"><code>Dagger.get_processors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_processors(proc::Processor) -&gt; Vector{T} where T&lt;:Processor</code></pre><p>Returns the full list of processors contained in <code>proc</code>, if any. <code>Processor</code> subtypes should overload this function if they can contain sub-processors. The default method will return a <code>Vector</code> containing <code>proc</code> itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.get_parent" href="#Dagger.get_parent"><code>Dagger.get_parent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_parent(proc::Processor) -&gt; Processor</code></pre><p>Returns the parent processor for <code>proc</code>. The ultimate parent processor is an <code>OSProc</code>. <code>Processor</code> subtypes should overload this to return their most direct parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.move" href="#Dagger.move"><code>Dagger.move</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">move(from_proc::Processor, to_proc::Processor, x)</code></pre><p>Moves and/or converts <code>x</code> such that it&#39;s available and suitable for usage on the <code>to_proc</code> processor. This function can be overloaded by <code>Processor</code> subtypes to transport arguments and convert them to an appropriate form before being used for exection. Subtypes of <code>Processor</code> wishing to implement efficient data movement should provide implementations where <code>x::Chunk</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL67-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.capacity" href="#Dagger.capacity"><code>Dagger.capacity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">capacity(proc::Processor=OSProc()) -&gt; Int</code></pre><p>Returns the total processing capacity of <code>proc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.get_tls" href="#Dagger.get_tls"><code>Dagger.get_tls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_tls()</code></pre><p>Gets all Dagger TLS variable as a <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.set_tls!" href="#Dagger.set_tls!"><code>Dagger.set_tls!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_tls!(tls)</code></pre><p>Sets all Dagger TLS variables from the <code>NamedTuple</code> <code>tls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL331-L335">source</a></section></article><h2 id="Shard-Functions"><a class="docs-heading-anchor" href="#Shard-Functions">Shard Functions</a><a id="Shard-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Shard-Functions" title="Permalink"></a></h2><p><a href="api/@ref"><code>Dagger.@shard</code></a> <a href="api/@ref"><code>Dagger.shard</code></a></p><h2 id="Context-Functions"><a class="docs-heading-anchor" href="#Context-Functions">Context Functions</a><a id="Context-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Context-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Dagger.addprocs!" href="#Dagger.addprocs!"><code>Dagger.addprocs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addprocs!(ctx::Context, xs)</code></pre><p>Add new workers <code>xs</code> to <code>ctx</code>.</p><p>Workers will typically be assigned new tasks in the next scheduling iteration if scheduling is ongoing.</p><p>Workers can be either <code>Processor</code>s or the underlying process IDs as <code>Integer</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL277-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.rmprocs!" href="#Dagger.rmprocs!"><code>Dagger.rmprocs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rmprocs!(ctx::Context, xs)</code></pre><p>Remove the specified workers <code>xs</code> from <code>ctx</code>.</p><p>Workers will typically finish all their assigned tasks if scheduling is ongoing but will not be assigned new tasks after removal.</p><p>Workers can be either <code>Processor</code>s or the underlying process IDs as <code>Integer</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL291-L299">source</a></section></article><h2 id="Logging-Functions"><a class="docs-heading-anchor" href="#Logging-Functions">Logging Functions</a><a id="Logging-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Logging-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Dagger.get_logs!" href="#Dagger.get_logs!"><code>Dagger.get_logs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_logs!(::LocalEventLog, raw=false; only_local=false) -&gt; Union{Vector{Timespan},Vector{Event}}</code></pre><p>Get the logs from each process&#39; local event log, clearing it in the process. Set <code>raw</code> to <code>true</code> to get potentially unmatched <code>Event</code>s; the default is to return only matched events as <code>Timespan</code>s. If <code>only_local</code> is set <code>true</code>, only process-local logs will be fetched; the default is to fetch logs from all processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/lib/logging.jl#LL116-L124">source</a></section></article><h2 id="Thunk-Execution-Environment-Functions"><a class="docs-heading-anchor" href="#Thunk-Execution-Environment-Functions">Thunk Execution Environment Functions</a><a id="Thunk-Execution-Environment-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Thunk-Execution-Environment-Functions" title="Permalink"></a></h2><p>These functions are used within the function called by a <code>Thunk</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Dagger.in_thunk" href="#Dagger.in_thunk"><code>Dagger.in_thunk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">in_thunk()</code></pre><p>Returns <code>true</code> if currently in a <a href="../types/#Dagger.Thunk"><code>Thunk</code></a> process, else <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL312-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.thunk_processor" href="#Dagger.thunk_processor"><code>Dagger.thunk_processor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">thunk_processor()</code></pre><p>Get the current processor executing the current thunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/processor.jl#LL305-L309">source</a></section></article><h3 id="Dynamic-Scheduler-Control-Functions"><a class="docs-heading-anchor" href="#Dynamic-Scheduler-Control-Functions">Dynamic Scheduler Control Functions</a><a id="Dynamic-Scheduler-Control-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-Scheduler-Control-Functions" title="Permalink"></a></h3><p>These functions query and control the scheduler remotely.</p><article class="docstring"><header><a class="docstring-binding" id="Dagger.Sch.sch_handle" href="#Dagger.Sch.sch_handle"><code>Dagger.Sch.sch_handle</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Gets the scheduler handle for the currently-executing thunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/sch/dynamic.jl#LL18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Sch.add_thunk!" href="#Dagger.Sch.add_thunk!"><code>Dagger.Sch.add_thunk!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Adds a new Thunk to the DAG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/sch/dynamic.jl#LL184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fetch" href="#Base.fetch"><code>Base.fetch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fetch(d::DTable)</code></pre><p>Collects all the chunks in the <code>DTable</code> into a single, non-distributed instance of the underlying table type.</p><p>Fetching an empty DTable results in returning an empty <code>NamedTuple</code> regardless of the underlying <code>tabletype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/dtable.jl#LL106-L113">source</a></section><section><div><pre><code class="nohighlight hljs">fetch(d::DTable, sink)</code></pre><p>Collects all the chunks in the <code>DTable</code> into a single, non-distributed instance of table type created using the provided <code>sink</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/table/dtable.jl#LL119-L124">source</a></section><section><div><p>Waits on a thunk to complete, and fetches its result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/sch/dynamic.jl#LL124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.wait" href="#Base.wait"><code>Base.wait</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Waits on a thunk to complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/sch/dynamic.jl#LL160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Sch.exec!" href="#Dagger.Sch.exec!"><code>Dagger.Sch.exec!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Executes an arbitrary function within the scheduler, returning the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/sch/dynamic.jl#LL106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Sch.halt!" href="#Dagger.Sch.halt!"><code>Dagger.Sch.halt!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Commands the scheduler to halt execution immediately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/sch/dynamic.jl#LL116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Sch.get_dag_ids" href="#Dagger.Sch.get_dag_ids"><code>Dagger.Sch.get_dag_ids</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns all Thunks IDs as a Dict, mapping a Thunk to its downstream dependents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/sch/dynamic.jl#LL166">source</a></section></article><h2 id="File-IO-Functions"><a class="docs-heading-anchor" href="#File-IO-Functions">File IO Functions</a><a id="File-IO-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#File-IO-Functions" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>These APIs are currently untested and may be removed or modified.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Dagger.save" href="#Dagger.save"><code>Dagger.save</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">save(io::IO, val)</code></pre><p>Save a value into the IO buffer. In the case of arrays and sparse matrices, this will save it in a memory-mappable way.</p><p><code>load(io::IO, t::Type, domain)</code> will load the object given its domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/file-io.jl#LL16-L23">source</a></section><section><div><pre><code class="nohighlight hljs">save(ctx, chunk::Union{Chunk, Thunk}, file_path::AbsractString)</code></pre><p>Save a chunk to a file at <code>file_path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/file-io.jl#LL36-L40">source</a></section><section><div><pre><code class="nohighlight hljs">save(ctx, chunk, file_path)</code></pre><p>Special case distmem writing - write to disk on the process with the chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/file-io.jl#LL47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.load" href="#Dagger.load"><code>Dagger.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load(ctx::Context, file_path)</code></pre><p>Load an Union{Chunk, Thunk} from a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/file-io.jl#LL122-L126">source</a></section><section><div><pre><code class="nohighlight hljs">load(ctx::Context, ::Type{Chunk}, fpath, io)</code></pre><p>Load a Chunk object from a file, the file path is required for creating a FileReader object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/file-io.jl#LL142-L147">source</a></section></article><h1 id="Macros-API"><a class="docs-heading-anchor" href="#Macros-API">Macros API</a><a id="Macros-API-1"></a><a class="docs-heading-anchor-permalink" href="#Macros-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Dagger.@par" href="#Dagger.@par"><code>Dagger.@par</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@par [opts] f(args...) -&gt; Thunk</code></pre><p>Convenience macro to call <code>Dagger.delayed</code> on <code>f</code> with arguments <code>args</code>. May also be called with a series of assignments like so:</p><pre><code class="language-julia hljs">x = @par begin
    a = f(1,2)
    b = g(a,3)
    h(a,b)
end</code></pre><p><code>x</code> will hold the Thunk representing <code>h(a,b)</code>; additionally, <code>a</code> and <code>b</code> will be defined in the same local scope and will be equally accessible for later calls.</p><p>Options to the <code>Thunk</code> can be set as <code>opts</code> with namedtuple syntax, e.g. <code>single=1</code>. Multiple options may be provided, and will be applied to all generated thunks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/thunk.jl#LL274-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.@spawn" href="#Dagger.@spawn"><code>Dagger.@spawn</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@spawn [opts] f(args...) -&gt; Thunk</code></pre><p>Convenience macro like <code>Dagger.@par</code>, but eagerly executed from the moment it&#39;s called (equivalent to <code>spawn</code>).</p><p>See the docs for <code>@par</code> for more information and usage examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/566c35b12c68e85f15850616ff10cea42e252ff2/src/thunk.jl#LL302-L309">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../../scheduler-internals/">Scheduler Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 12 December 2021 00:13">Sunday 12 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
