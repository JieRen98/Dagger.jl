<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Logging and Graphing · Dagger.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/logging/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dagger.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../dtable/">Distributed Table</a></li><li><a class="tocitem" href="../processors/">Processors</a></li><li><a class="tocitem" href="../scopes/">Scopes</a></li><li><a class="tocitem" href="../mutation/">Mutation and Shards</a></li><li><a class="tocitem" href="../dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="../propagation/">Option Propagation</a></li><li class="is-active"><a class="tocitem" href>Logging and Graphing</a><ul class="internal"><li><a class="tocitem" href="#MultiEventLog"><span>MultiEventLog</span></a></li><li><a class="tocitem" href="#LocalEventLog"><span>LocalEventLog</span></a></li><li><a class="tocitem" href="#FilterLog"><span>FilterLog</span></a></li></ul></li><li><a class="tocitem" href="../scheduler-visualization/">Scheduler Visualization</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/types/">Types</a></li><li><a class="tocitem" href="../api/functions/">Functions and Macros</a></li></ul></li><li><a class="tocitem" href="../scheduler-internals/">Scheduler Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Logging and Graphing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Logging and Graphing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/logging.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Logging-and-Graphing"><a class="docs-heading-anchor" href="#Logging-and-Graphing">Logging and Graphing</a><a id="Logging-and-Graphing-1"></a><a class="docs-heading-anchor-permalink" href="#Logging-and-Graphing" title="Permalink"></a></h1><p>Dagger&#39;s scheduler keeps track of the important and potentially expensive actions it does, such as moving data between workers or executing thunks, and tracks how much time and memory allocations these operations consume, among other things. Saving this information somewhere accessible is disabled by default, but it&#39;s quite easy to turn it on, by setting a &quot;log sink&quot; in the <code>Context</code> being used, as <code>ctx.log_sink</code>. A variety of log sinks are built-in to Dagger; the <code>NoOpLog</code> is the default log sink when one isn&#39;t explicitly specified, and disables logging entirely (to minimize overhead). There are currently two other log sinks of interest; the first and newer of the two is the <code>Dagger.MultiEventLog</code>, which generates multiple independent log streams, one per &quot;consumer&quot; (details in the next section). The second and older sink is the <code>Dagger.LocalEventLog</code>, which is explained later in this document. Most users are recommended to use the <code>MultiEventLog</code> since it&#39;s far more flexible and extensible, and is more performant in general.</p><h2 id="MultiEventLog"><a class="docs-heading-anchor" href="#MultiEventLog">MultiEventLog</a><a id="MultiEventLog-1"></a><a class="docs-heading-anchor-permalink" href="#MultiEventLog" title="Permalink"></a></h2><p>The <code>MultiEventLog</code> is intended to be configurable to exclude unnecessary information, and to include any built-in or user-defined metrics. It stores a set of &quot;sub-log&quot; streams internally, appending a single element to each of them when an event is generated. This element can be called a &quot;sub-event&quot; (to distinguish it from the higher-level &quot;event&quot; that Dagger creates), and is created by a &quot;consumer&quot;. A consumer is a function or callable struct that, when called with the <code>Dagger.Event</code> object generated by Dagger, returns a sub-event characterizing whatever information the consumer represents. For example, the <code>Dagger.Events.BytesAllocd</code> consumer calculates the total bytes allocated and live at any given time within Dagger, and returns the current value when called. Let&#39;s construct one:</p><pre><code class="language-julia hljs">ctx = Context()
ml = Dagger.MultiEventLog()

# Add the BytesAllocd consumer to the log as `:bytes`
ml[:bytes] = Dagger.Events.BytesAllocd()

ctx.log_sink = ml</code></pre><p>As we can see above, each consumer gets a unique name as a <code>Symbol</code> that identifies it. Now that the log sink is attached with a consumer, we can execute some Dagger tasks, and then collect the sub-events generated by <code>BytesAllocd</code>:</p><pre><code class="language-julia hljs"># Using the lazy API, for explanatory purposes
collect(ctx, delayed(+)(1, delayed(*)(3, 4))) # Allocates 8 bytes
log = Dagger.get_logs!(ml)[1] # Get the logs for worker 1
@show log[:bytes]</code></pre><p>You&#39;ll then see that 8 bytes are allocated and then freed during the process of executing and completing those tasks.</p><p>Note that the <code>MultiEventLog</code> can also be used perfectly well when using Dagger&#39;s eager API:</p><pre><code class="language-julia hljs">ctx = Dagger.Sch.eager_context()
ctx.log_sink = ml

a = Dagger.@spawn 3*4
Dagger.@spawn 1+a</code></pre><p>There are a variety of other consumers built-in to Dagger, under the <code>Dagger.Events</code> module:</p><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.CoreMetrics" href="#Dagger.Events.CoreMetrics"><code>Dagger.Events.CoreMetrics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoreMetrics</code></pre><p>Tracks the timestamp, category, and kind of the <code>Event</code> object generated by log events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.IDMetrics" href="#Dagger.Events.IDMetrics"><code>Dagger.Events.IDMetrics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IDMetrics</code></pre><p>Tracks the ID of <code>Event</code> objects generated by log events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.TimelineMetrics" href="#Dagger.Events.TimelineMetrics"><code>Dagger.Events.TimelineMetrics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimelineMetrics</code></pre><p>Tracks the timeline of <code>Event</code> objects generated by log events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.FullMetrics" href="#Dagger.Events.FullMetrics"><code>Dagger.Events.FullMetrics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FullMetrics</code></pre><p>Tracks the full <code>Event</code> object generated by log events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.BytesAllocd" href="#Dagger.Events.BytesAllocd"><code>Dagger.Events.BytesAllocd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BytesAllocd</code></pre><p>Tracks memory allocated for <code>Chunk</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.CPULoadAverages" href="#Dagger.Events.CPULoadAverages"><code>Dagger.Events.CPULoadAverages</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CPULoadAverages</code></pre><p>Monitors the CPU load averages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.MemoryFree" href="#Dagger.Events.MemoryFree"><code>Dagger.Events.MemoryFree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MemoryFree</code></pre><p>Monitors the percentage of free system memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.EventSaturation" href="#Dagger.Events.EventSaturation"><code>Dagger.Events.EventSaturation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EventSaturation</code></pre><p>Tracks the compute saturation (running tasks) per-processor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.WorkerSaturation" href="#Dagger.Events.WorkerSaturation"><code>Dagger.Events.WorkerSaturation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WorkerSaturation</code></pre><p>Tracks the compute saturation (running tasks).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.ProcessorSaturation" href="#Dagger.Events.ProcessorSaturation"><code>Dagger.Events.ProcessorSaturation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProcessorSaturation</code></pre><p>Tracks the compute saturation (running tasks) per-processor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL137-L141">source</a></section></article><p>The <code>MultiEventLog</code> also has a mechanism to call a set of functions, called &quot;aggregators&quot;, after all consumers have been executed, and are passed the full set of log streams as a <code>Dict{Symbol,Vector{Any}}</code>. The only one currently shipped with Dagger directly is the <code>LogWindow</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.LogWindow" href="#Dagger.Events.LogWindow"><code>Dagger.Events.LogWindow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogWindow</code></pre><p>Aggregator that prunes events to within a given time window.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dagger.Events.TableStorage" href="#Dagger.Events.TableStorage"><code>Dagger.Events.TableStorage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TableStorage</code></pre><p>LogWindow-compatible aggregator which stores logs in a Tables.jl-compatible sink.</p><p>Using a <code>TableStorage</code> is reasonably simple:</p><pre><code class="language-julia hljs">ml = Dagger.MultiEventLog()

... # Add some events

lw = Dagger.Events.LogWindow(5*10^9, :core)

# Create a DataFrame with one Any[] for each event
df = DataFrame([key=&gt;[] for key in keys(ml.consumers)]...)

# Create the TableStorage and register its creation handler
ts = Dagger.Events.TableStorage(df)
push!(lw.creation_handlers, ts)

ml.aggregators[:lw] = lw

# Logs will now be saved into `df` automatically, and packages like
# DaggerWebDash.jl will automatically use it to retrieve subsets of the logs.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaParallel/Dagger.jl/blob/578d76c7cb3a8ab05fdb2819c0f1f9d49637b682/src/lib/logging-extras.jl#LL229-L256">source</a></section></article><h2 id="LocalEventLog"><a class="docs-heading-anchor" href="#LocalEventLog">LocalEventLog</a><a id="LocalEventLog-1"></a><a class="docs-heading-anchor-permalink" href="#LocalEventLog" title="Permalink"></a></h2><p>The <code>LocalEventLog</code> is generally only useful when you want combined events (event start and finish combined as a single unit), and only care about a few simple built-in generated events. Let&#39;s attach one to our context:</p><pre><code class="language-julia hljs">ctx = Context()
log = Dagger.LocalEventLog()
ctx.log_sink = log</code></pre><p>Now anytime <code>ctx</code> is used as the context for a scheduler, the scheduler will log events into <code>log</code>.</p><p>Once sufficient data has been accumulated into a <code>LocalEventLog</code>, it can be gathered to a single host via <code>Dagger.get_logs!(log)</code>. The result is a <code>Vector</code> of <code>Dagger.Timespan</code> objects, which describe some metadata about an operation that occured and the scheduler logged. These events may be introspected directly, or may also be rendered to a DOT-format string:</p><pre><code class="language-julia hljs">logs = Dagger.get_logs!(log)
str = Dagger.show_plan(logs)</code></pre><p><code>Dagger.show_plan</code> can also be called as <code>Dagger.show_plan(io::IO, logs)</code> to write the graph to a file or other <code>IO</code> object. The string generated by this function may be passed to an external tool like <code>Graphviz</code> for rendering. Note that this method doesn&#39;t display input arguments to the DAG (non-<code>Thunk</code>s); you can call <code>Dagger.show_plan(logs, thunk)</code>, where <code>thunk</code> is the output <code>Thunk</code> of the DAG, to render argument nodes.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Dagger.get_logs!</code> clears out the event logs, so that old events don&#39;t mix with new ones from future DAGs.</p></div></div><p>As a convenience, it&#39;s possible to set <code>ctx.log_file</code> to the path to an output file, and then calls to <code>compute(ctx, ...)</code>/<code>collect(ctx, ...)</code> will automatically write the graph in DOT format to that path. There is also a benefit to this approach over manual calls to <code>get_logs!</code> and <code>show_plan</code>: DAGs which aren&#39;t <code>Thunk</code>s (such as operations on the <code>Dagger.DArray</code>) will be properly rendered with input arguments (which normally aren&#39;t rendered because a <code>Thunk</code> is dynamically generated from such operations by Dagger before scheduling).</p><h2 id="FilterLog"><a class="docs-heading-anchor" href="#FilterLog">FilterLog</a><a id="FilterLog-1"></a><a class="docs-heading-anchor-permalink" href="#FilterLog" title="Permalink"></a></h2><p>The <code>FilterLog</code> exists to allow writing events to a user-defined location (such as a database, file, or network socket). It is not currently tested or documented.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../propagation/">« Option Propagation</a><a class="docs-footer-nextpage" href="../scheduler-visualization/">Scheduler Visualization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Wednesday 27 April 2022 02:47">Wednesday 27 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
