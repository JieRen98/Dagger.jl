<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scopes · Dagger.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/scopes/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dagger.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../dtable/">Distributed Table</a></li><li><a class="tocitem" href="../processors/">Processors</a></li><li class="is-active"><a class="tocitem" href>Scopes</a><ul class="internal"><li><a class="tocitem" href="#Scope-Basics"><span>Scope Basics</span></a></li><li><a class="tocitem" href="#Union-Scopes"><span>Union Scopes</span></a></li><li><a class="tocitem" href="#Mismatched-Scopes"><span>Mismatched Scopes</span></a></li></ul></li><li><a class="tocitem" href="../mutation/">Mutation and Shards</a></li><li><a class="tocitem" href="../dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="../logging/">Logging and Graphing</a></li><li><a class="tocitem" href="../scheduler-visualization/">Scheduler Visualization</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/types/">Types</a></li><li><a class="tocitem" href="../api/functions/">Functions and Macros</a></li></ul></li><li><a class="tocitem" href="../scheduler-internals/">Scheduler Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Scopes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Scopes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/scopes.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Scopes"><a class="docs-heading-anchor" href="#Scopes">Scopes</a><a id="Scopes-1"></a><a class="docs-heading-anchor-permalink" href="#Scopes" title="Permalink"></a></h1><p>Sometimes you will have data that is only meaningful in a certain location, such as within a single Julia process, a given server, or even for a specific Dagger processor. We call this location a &quot;scope&quot; in Dagger, denoting the bounds within which the data is meaningful and valid. For example, C pointers are typically scoped to a process, file paths are scoped to one or more servers dependent on filesystem configuration, etc. By default, Dagger doesn&#39;t recognize this; it treats everything passed into a task, or generated from a task, as inherently safe to transfer anywhere else. When this is not the case, Dagger provides optional scopes to instruct the scheduler where data is considered valid.</p><h2 id="Scope-Basics"><a class="docs-heading-anchor" href="#Scope-Basics">Scope Basics</a><a id="Scope-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Scope-Basics" title="Permalink"></a></h2><p>Let&#39;s take the example of a webcam handle generated by VideoIO.jl. This handle is a C pointer, and thus has process scope. We can open the handle on a given process, and set the scope of the resulting data to a <code>ProcessScope()</code>, which defaults to the current Julia process:</p><pre><code class="language-julia hljs">using VideoIO

function get_handle()
    handle = VideoIO.opencamera()
    proc = Dagger.thunk_processor()
    scope = ProcessScope()
    return Dagger.tochunk(handle, proc, scope)
end

cam_handle = Dagger.@spawn get_handle()</code></pre><p>Now, wherever <code>cam_handle</code> is passed, Dagger will ensure that any computations on the handle only happen within its defined scope. For example, we can read from the camera:</p><pre><code class="language-julia hljs">cam_frame = Dagger.@spawn read(cam_handle)</code></pre><p>The <code>cam_frame</code> task is executed within any processor on the same process that the <code>cam_handle</code> task was executed on. Of course, the resulting camera frame is <em>not</em> scoped to anywhere specific (denoted as <code>AnyScope()</code>), and thus computations on it may execute anywhere.</p><p>You may also encounter situations where you want to use a callable struct (such as a closure, or a Flux.jl layer) only within a certain scope; you can specify the scope of the function pretty easily:</p><pre><code class="language-julia hljs">using Flux
m = Chain(...)
# If `m` is only safe to transfer to and execute on this process,
# we can set a `ProcessScope` on it:
result = Dagger.@spawn scope=ProcessScope() m(rand(8,8))</code></pre><p>Setting a scope on the function treats it as a regular piece of data (like the arguments to the function), so it participates in the scoping rules described in the following sections all the same.</p><p>Now, let&#39;s try out some other kinds of scopes, starting with <code>NodeScope</code>. This scope encompasses the server that one or more Julia processes may be running on. Say we want to use memory mapping (mmap) to more efficiently send arrays between two tasks. We can construct the mmap&#39;d array in one task, attach a <code>NodeScope()</code> to it, and using the path of the mmap&#39;d file to communicate its location, lock downstream tasks to the same server:</p><pre><code class="language-julia hljs">using Mmap

function generate()
    path = &quot;myfile.bin&quot;
    arr = Mmap.mmap(path, Matrix{Int}, (64,64))
    fill!(arr, 1)
    Mmap.sync!(arr)
    Dagger.tochunk(path, Dagger.thunk_processor(), NodeScope())
end

function consume(path)
    arr = Mmap.mmap(path, Matrix{Int}, (64,64))
    sum(arr)
end

a = Dagger.@spawn generate()
@assert fetch(Dagger.@spawn consume(a)) == 64*64</code></pre><p>Whatever server <code>a</code> executed on, <code>b</code> will also execute on!</p><p>Finally, we come to the &quot;lowest&quot; scope on the scope hierarchy, the <code>ExactScope</code>. This scope specifies one exact processor as the bounding scope, and is typically useful in certain limited cases. We won&#39;t provide an example here, because you don&#39;t usually need to ever use this scope, but if you already understand the <code>NodeScope</code> and <code>ProcessScope</code>, the <code>ExactScope</code> should be easy to figure out.</p><h2 id="Union-Scopes"><a class="docs-heading-anchor" href="#Union-Scopes">Union Scopes</a><a id="Union-Scopes-1"></a><a class="docs-heading-anchor-permalink" href="#Union-Scopes" title="Permalink"></a></h2><p>Sometimes one simple scope isn&#39;t enough! In that case, you can use the <code>UnionScope</code> to construct the union of two or more scopes. Say, for example, you have some sensitive data on your company&#39;s servers that you want to compute summaries of, but you&#39;ll be driving the computation from your laptop, and you aren&#39;t allowed to send the data itself outside of the company&#39;s network. You could accomplish this by constructing a <code>UnionScope</code> of <code>ProcessScope</code>s of each of the non-laptop Julia processes, and use that to ensure that the data in its original form always stays within the company network:</p><pre><code class="language-julia hljs">addprocs(4) # some local processors
procs = addprocs([(&quot;server.company.com&quot;, 4)]) # some company processors

secrets_scope = UnionScope(ProcessScope.(procs))

function generate_secrets()
    secrets = open(&quot;/shared/secret_results.txt&quot;, &quot;r&quot;) do io
        String(read(io))
    end
    Dagger.tochunk(secrets, Dagger.thunk_processor(), secrets_scope)
end

summarize(secrets) = occursin(&quot;QA Pass&quot;, secrets)

# Generate the data on the first company process
sensitive_data = Dagger.@spawn single=first(procs) generate_secrets()

# We can safely call this, knowing that it will be executed on a company server
qa_passed = Dagger.@spawn summarize(sensitive_data)</code></pre><h2 id="Mismatched-Scopes"><a class="docs-heading-anchor" href="#Mismatched-Scopes">Mismatched Scopes</a><a id="Mismatched-Scopes-1"></a><a class="docs-heading-anchor-permalink" href="#Mismatched-Scopes" title="Permalink"></a></h2><p>You might now be thinking, &quot;What if I want to run a task on multiple pieces of data whose scopes don&#39;t match up?&quot; In such a case, Dagger will throw an error, refusing to schedule that task, since the intersection of the data scopes is an empty set (there is no feasible processor which can satisfy the scoping constraints). For example:</p><pre><code class="language-julia hljs">ps2 = ProcessScope(2)
ps3 = ProcessScope(3)

generate(scope) = Dagger.tochunk(rand(64), Dagger.thunk_processor(), scope)

d2 = Dagger.@spawn generate(ps2) # Run on process 2
d3 = Dagger.@spawn generate(ps3) # Run on process 3
res = Dagger.@spawn d2 * d3 # An error!</code></pre><p>Moral of the story: only use scopes when you know you really need them, and if you aren&#39;t careful to arrange everything just right, be prepared for Dagger to refuse to schedule your tasks! Scopes should only be used to ensure correctness of your programs, and are <em>not</em> intended to be used to optimize the schedule that Dagger uses for your tasks, since restricting the scope of execution for tasks will necessarily reduce the optimizations that Dagger&#39;s scheduler can perform.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../processors/">« Processors</a><a class="docs-footer-nextpage" href="../mutation/">Mutation and Shards »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 7 December 2021 17:06">Tuesday 7 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
