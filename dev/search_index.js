var documenterSearchIndex = {"docs":
[{"location":"dynamic/#Dynamic-Scheduler-Control","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"","category":"section"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"Normally, Dagger executes static graphs defined with delayed and @par. However, it is possible for thunks to dynamically modify the graph at runtime, and to generally exert direct control over the scheduler's internal state. The Dagger.sch_handle function provides this functionality within a thunk:","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"function mythunk(x)\n    h = Dagger.sch_handle()\n    Dagger.halt!(h)\n    return x\nend","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"The above example prematurely halts a running scheduler at the next opportunity using Dagger.halt!:","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"Dagger.halt!","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"There are a variety of other built-in functions available for various uses:","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"Dagger.get_dag_ids Dagger.add_thunk!","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"When working with thunks acquired from get_dag_ids or add_thunk!, you will have ThunkID objects which refer to a thunk by ID. Scheduler control functions which work with thunks accept or return ThunkIDs. For example, one can create a new thunkt and get its result with Base.fetch:","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"function mythunk(x)\n    h = Dagger.sch_handle()\n    id = Dagger.add_thunk!(h, x) do y\n        y + 1\n    end\n    return fetch(h, id)\nend","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"Alternatively, Base.wait can be used when one does not wish to retrieve the returned value of the thunk.","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"Users with needs not covered by the built-in functions should use the Dagger.exec! function to pass a user-defined function, closure, or callable struct to the scheduler, along with a payload which will be provided to that function:","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"Dagger.exec!","category":"page"},{"location":"dynamic/","page":"Dynamic Scheduler Control","title":"Dynamic Scheduler Control","text":"Note that all functions called by Dagger.exec! take the scheduler's internal lock, so it's safe to manipulate the internal ComputeState object within the user-provided function.","category":"page"},{"location":"scheduler-internals/#Scheduler-Internals","page":"Scheduler Internals","title":"Scheduler Internals","text":"","category":"section"},{"location":"scheduler-internals/","page":"Scheduler Internals","title":"Scheduler Internals","text":"warn: Warn\nThis information is outdated, and until Dagger's internal scheduling APIs stabilize, it may become less and less accurate. Always read the source to understand what actually happens in Sch!","category":"page"},{"location":"scheduler-internals/","page":"Scheduler Internals","title":"Scheduler Internals","text":"The scheduler is called Dagger.Sch. It contains a single internal instance of type ComputeState, which maintains all necessary state to represent the set of waiting, ready, and completed (or \"finished\") graph nodes, cached Chunks, and maps of interdependencies between nodes. It uses Julia's task infrastructure to asynchronously send work requests to remote compute processes, and uses a Julia Channel as an inbound queue for completed work. There is an outer loop which drives the scheduler, which continues executing until all nodes in the graph have completed executing and the final result of the graph is ready to be returned to the user. This outer loop continuously performs two main operations: the first is to launch the execution of nodes which have become \"ready\" to execute; the second is to \"finish\" nodes which have been completed.","category":"page"},{"location":"scheduler-internals/#Scheduler-Initialization","page":"Scheduler Internals","title":"Scheduler Initialization","text":"","category":"section"},{"location":"scheduler-internals/","page":"Scheduler Internals","title":"Scheduler Internals","text":"At the very beginning of a scheduler's lifecycle, the ComputeState is elaborated based on the computed sets of dependencies between nodes, and all nodes are placed in a \"waiting\" state. If any of the nodes are found to only have inputs which are not Thunks, then they are moved from \"waiting\" to \"ready\". The set of available \"workers\" (the set of available compute processes located throughout the cluster) is recorded, of size Nworkers.","category":"page"},{"location":"scheduler-internals/#Scheduler-Outer-Loop","page":"Scheduler Internals","title":"Scheduler Outer Loop","text":"","category":"section"},{"location":"scheduler-internals/","page":"Scheduler Internals","title":"Scheduler Internals","text":"At each outer loop iteration, up to Nworkers processes that are currently in the \"ready\" state will be moved into the \"running\" state, and asynchronously sent (along with input arguments) to one of the Nworkers processes for execution. Subsequently, if any nodes exist in the inbound queue (i.e. the nodes have completed execution and their result is stored on the process that executed the node), then the most recently-queued node is removed from the queue, \"finished\", and placed in the \"finished\" state.","category":"page"},{"location":"scheduler-internals/#Node-Execution","page":"Scheduler Internals","title":"Node Execution","text":"","category":"section"},{"location":"scheduler-internals/","page":"Scheduler Internals","title":"Scheduler Internals","text":"Executing a node (here called Ne) in the \"ready\" state comprises two tasks. The first task is to identify which node in the set of \"ready\" nodes will be Ne (the node to execute). This choice is based on a concept known as \"affinity\", which is a cost-based metric used to evaluate the suitability of executing a given node on a given process. The metric is based primarily on the location of the input arguments to the node, as well as the arguments computed size in bytes. A fixed amount of affinity is added for each argument when the process in question houses that argument. Affinity is then added based on some base affinity value multiplied by the argument's size in bytes. The total affinities for each node are then used to pick the most optimal node to execute (typically, the one with the highest affinity).","category":"page"},{"location":"scheduler-internals/","page":"Scheduler Internals","title":"Scheduler Internals","text":"The second task is to prepare and send the node to a process for execution. If the node has been executed in the past (due to it being an argument to multiple other nodes), then the node is finished, and its result is pulled from the cache. If the node has not yet been executed, it is first checked if it is a \"meta\" node. A \"meta\" node is explicitly designated as such by the user or library, and will execute directly on its inputs as chunks (the data contained in the chunks are not immediately retrieved from the processors they reside on). Such a node will be executed directly within the scheduler, under the assumption that such a node is not expensive to execute. If the node is not a \"meta\" node, the executing worker process chooses (in round-robin fashion) a suitable processor to execute to execute the node on, based on the node's function, the input argument types, and user-defined rules for processor selection. The input arguments are then asynchronously transferred (via processor move operation) to the selected processor, and the appropriate call to the processor is made with the function and input arguments. Once execution completes and a result is obtained, it is wrapped as a Chunk, and the Chunk's handle is returned to the scheduler's inbound queue for node finishing.","category":"page"},{"location":"scheduler-internals/#Node-Finishing","page":"Scheduler Internals","title":"Node Finishing","text":"","category":"section"},{"location":"scheduler-internals/","page":"Scheduler Internals","title":"Scheduler Internals","text":"\"Finishing\" a node (here called Nf) performs three main tasks. The first task is to find all of the downstream \"children\" nodes of Nf (the set of nodes which use Nf's result as one of their input arguments) that have had all of their input arguments computed and are in the \"waiting\" state, and move them into the \"ready\" state. The second task is to check all of the inputs to Nf to determine if any of them no longer have children nodes which have not been finished; if such inputs match this pattern, their cached result may be freed by the scheduler to minimize data usage. The third task is to mark Nf as \"finished\", and also to indicate to the scheduler whether another node has become \"ready\" to execute.","category":"page"},{"location":"scheduler-visualization/#Scheduler-Visualization-with-DaggerWebDash","page":"Scheduler Visualization","title":"Scheduler Visualization with DaggerWebDash","text":"","category":"section"},{"location":"scheduler-visualization/","page":"Scheduler Visualization","title":"Scheduler Visualization","text":"When working with Dagger, especially when working with its scheduler, it can be helpful to visualize what Dagger is doing internally. To assist with this, a web dashboard is available in the DaggerWebDash.jl package. This web dashboard uses a web server running within each Dagger worker, along with event logging information, to expose details about the scheduler. Information like worker and processor saturation, memory allocations, profiling traces, and much more are available in easy-to-interpret plots.","category":"page"},{"location":"scheduler-visualization/","page":"Scheduler Visualization","title":"Scheduler Visualization","text":"Using the dashboard is relatively simple and straightforward; if you run Dagger's benchmarking script, it's enabled for you automatically if the BENCHMARK_RENDER environment variable is set to webdash. This is the easiest way to get started with the web dashboard for new users.","category":"page"},{"location":"scheduler-visualization/","page":"Scheduler Visualization","title":"Scheduler Visualization","text":"For manual usage, the following snippet of code will suffice:","category":"page"},{"location":"scheduler-visualization/","page":"Scheduler Visualization","title":"Scheduler Visualization","text":"ctx = Context() # or `ctx = Dagger.Sch.eager_context()` for eager API usage\nml = Dagger.MultiEventLog()\n\n## Add some logging events of interest\n\nml[:core] = Dagger.Events.CoreMetrics()\nml[:id] = Dagger.Events.IDMetrics()\nml[:timeline] = Dagger.Events.TimelineMetrics()\n# ...\n\n# (Optional) Enable profile flamegraph generation with ProfileSVG\nml[:profile] = DaggerWebDash.ProfileMetrics()\nctx.profile = true\n\n# Create a LogWindow; necessary for real-time event updates\nlw = Dagger.Events.LogWindow(20*10^9, :core)\nml.aggregators[:logwindow] = lw\n\n# Create the D3Renderer server on port 8080\nd3r = DaggerWebDash.D3Renderer(8080)\n\n## Add some plots! Rendered top-down in order\n\n# Show an overview of all generated events as a Gantt chart\npush!(d3r, GanttPlot(:core, :id, :timeline, :esat, :psat, \"Overview\"))\n\n# Show various numerical events as line plots over time\npush!(d3r, LinePlot(:core, :wsat, \"Worker Saturation\", \"Running Tasks\"))\npush!(d3r, LinePlot(:core, :loadavg, \"CPU Load Average\", \"Average Running Threads\"))\npush!(d3r, LinePlot(:core, :bytes, \"Allocated Bytes\", \"Bytes\"))\npush!(d3r, LinePlot(:core, :mem, \"Available Memory\", \"% Free\"))\n\n# Show a graph rendering of compute tasks and data movement between them\n# Note: Profile events are ignored if absent from the log\npush!(d3r, GraphPlot(:core, :id, :timeline, :profile, \"DAG\"))\n\n# TODO: Not yet functional\n#push!(d3r, ProfileViewer(:core, :profile, \"Profile Viewer\"))\n\n# Add the D3Renderer as a consumer of special events generated by LogWindow\npush!(lw.creation_handlers, d3r)\npush!(lw.deletion_handlers, d3r)\n\n# D3Renderer is also an aggregator\nml.aggregators[:d3r] = d3r\n\nctx.log_sink = ml\n# ... use `ctx`","category":"page"},{"location":"scheduler-visualization/","page":"Scheduler Visualization","title":"Scheduler Visualization","text":"Once the server has started, you can browse to http://localhost:8080/ (if running on your local machine) to view the plots in real time. The dashboard also provides options at the top of the page to control the drawing speed, enable and disable reading updates from the server (disabling freezes the display at the current instant), and a selector for which worker to look at. If the connection to the server is lost for any reason, the dashboard will attempt to reconnect at 5 second intervals. The dashboard can usually survive restarts of the server perfectly well, although refreshing the page is usually a good idea. Informational messages are also logged to the browser console for debugging.","category":"page"},{"location":"propagation/#Option-Propagation","page":"Option Propagation","title":"Option Propagation","text":"","category":"section"},{"location":"propagation/","page":"Option Propagation","title":"Option Propagation","text":"Most options passed to Dagger are passed via delayed or Dagger.@spawn directly. This works well when an option only needs to be set for a single thunk, but is cumbersome when the same option needs to be set on multiple thunks, or set recursively on thunks spawned within other thunks. Thankfully, Dagger provides the with_options function to make this easier. This function is very powerful, by nature of using \"context variables\"; let's first see some example code to help explain it:","category":"page"},{"location":"propagation/","page":"Option Propagation","title":"Option Propagation","text":"function f(x)\n    m = Dagger.@spawn myid()\n    return Dagger.@spawn x+m\nend\nDagger.with_options(;scope=ProcessScope(2)) do\n    @sync begin\n        @async @assert fetch(Dagger.@spawn f(1)) == 3\n        @async @assert fetch(Dagger.@spawn f(2)) == 4\n    end\nend","category":"page"},{"location":"propagation/","page":"Option Propagation","title":"Option Propagation","text":"In the above example, with_options sets the scope for both Dagger.@spawn f(1) and Dagger.@spawn f(2) to ProcessScope(2) (locking Dagger tasks to worker 2). This is of course very useful for ensuring that a set of operations use a certain scope. What it also does, however, is propagates this scope through calls to @async, Threads.@spawn, and Dagger.@spawn; this means that the task spawned by f(x) also inherits this scope! This works thanks to the magic of context variables, which are inherited recursively through child tasks, and thanks to Dagger intentionally propagating the scope (and other options passed to with_options) across the cluster, ensuring that no matter how deep the recursive task spawning goes, the options are maintained.","category":"page"},{"location":"propagation/","page":"Option Propagation","title":"Option Propagation","text":"It's also possible to retrieve the options currently set by with_options, using Dagger.get_options:","category":"page"},{"location":"propagation/","page":"Option Propagation","title":"Option Propagation","text":"Dagger.with_options(;scope=ProcessScope(2)) do\n    fetch(@async @assert Dagger.get_options().scope == ProcessScope(2))\n    # Or:\n    fetch(@async @assert Dagger.get_options(:scope) == ProcessScope(2))\n    # Or, if `scope` might not have been propagated as an option, we can give\n    # it a default value:\n    fetch(@async @assert Dagger.get_options(:scope, AnyScope()) == ProcessScope(2))\nend","category":"page"},{"location":"propagation/","page":"Option Propagation","title":"Option Propagation","text":"This is a very powerful concept: with a single call to with_options, we can apply any set of options to any nested set of operations. This is great for isolating large workloads to different workers or processors, defining global checkpoint/restore behavior, and more.","category":"page"},{"location":"mutation/#Mutation-Support","page":"Mutation and Shards","title":"Mutation Support","text":"","category":"section"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"Normally, Dagger tasks should be functional and \"pure\": never mutating their inputs, always producing identical outputs for a given set of inputs, and never producing side effects which might affect future program behavior. However, for certain codes, this restriction ends up costing the user performance and engineering time to work around.","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"Thankfully, Dagger provides the Dagger.@mutable macro for just this purpose. @mutable allows data to be marked such that it will never be copied or serialized by the scheduler (unless copied by the user). When used as an argument to a task, the task will be forced to execute on the same worker that @mutable was called on. For example:","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"x = remotecall_fetch(2) do\n    Dagger.@mutable Threads.Atomic{Int}(0)\nend\nx::Dagger.Chunk # The result is always a `Chunk`\n\n# x is now considered mutable, and may only be accessed on worker 2:\nfetch(Dagger.@spawn Threads.atomic_add!(x, 3)) # Always executed on worker 2\nfetch(Dagger.@spawn single=1 Threads.atomic_add!(x, 3)) # SchedulingException","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"@mutable, when called as above, gain a scope of ProcessorScope(myid()), which means that any processor on that worker is allowed to execute tasks that use the object (subject to the usual scheduling rules).","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"@mutable also has two other forms, allowing the processor and scope to be manually supplied:","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"proc1 = Dagger.ThreadProc(myid(), 3)\nproc2 = Dagger.ThreadProc(myid(), 4)\nscope = Dagger.UnionScope(ExactScope.([proc1, proc2]))\nx = @mutable OSProc() scope rand(100)\n# x is now scoped to threads 3 and 4 on worker `myid()`","category":"page"},{"location":"mutation/#Sharding","page":"Mutation and Shards","title":"Sharding","text":"","category":"section"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"@mutable is convenient for creating a single mutable object, but often one wants to have multiple mutable objects, with each object being scoped to their own worker or thread in the cluster, to be used as local counters, partial reduction containers, data caches, etc.","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"The Shard object (constructed with Dagger.@shard/Dagger.shard) is a mechanism by which such a setup can be created with one invocation.  By default, each worker will have their own local object which will be used when a task that uses the shard as an argument is scheduled on that worker. Other shard pieces that aren't scoped to the processor being executed on will not be serialized or copied, keeping communication costs constant even with a very large shard.","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"This mechanism makes it easy to construct a distributed set of mutable objects which are treated as \"mirrored shards\" by the scheduler, but require no further user input to access. For example, creating and using a local counter for each worker is trivial:","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"# Create a local atomic counter on each worker that Dagger knows about:\ncs = Dagger.@shard Threads.Atomic{Int}(0)\n\n# Let's add `1` to the local counter, not caring about which worker we're on:\nwait.([Dagger.@spawn Threads.atomic_add!(cs, 1) for i in 1:1000])\n\n# And let's fetch the total sum of all counters:\n@assert sum(fetch.(map(ctr->ctr[], cs))) == 1000","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"Note that map, when used on a shard, will execute the provided function once per shard \"piece\", and each result is considered immutable. map is an easy way to make a copy of each piece of the shard, to be later reduced, scanned, etc.","category":"page"},{"location":"mutation/","page":"Mutation and Shards","title":"Mutation and Shards","text":"Further details about what arguments can be passed to @shard/shard can be found in Shard Functions.","category":"page"},{"location":"checkpointing/#Checkpointing","page":"Checkpointing","title":"Checkpointing","text":"","category":"section"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"If at some point during a Dagger computation a thunk throws an error, or if the entire computation dies because the head node hit an OOM or other unexpected error, the entire computation is lost and needs to be started from scratch. This can be unacceptable for scheduling very large/expensive/mission-critical graphs, and for interactive development where errors are common and easily fixable.","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Robust applications often support \"checkpointing\", where intermediate results are periodically written out to persistent media, or sharded to the rest of the cluster, to allow resuming an interrupted computation from a point later than the original start. Dagger provides infrastructure to perform user-driven checkpointing of intermediate results once they're generated.","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"As a concrete example, imagine that you're developing a numerical algorithm, and distributing it with Dagger. The idea is to sum all the values in a very big matrix, and then get the square root of the absolute value of the sum of sums. Here is what that might look like:","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"X = compute(randn(Blocks(128,128), 1024, 1024))\nY = [delayed(sum)(chunk) for chunk in X.chunks]\ninner(x...) = sqrt(sum(x))\nZ = delayed(inner)(Y...)\nz = collect(Z)","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Let's pretend that the above calculation of each element in Y takes a full day to run. If you run this, you might realize that if the final sum call returns a negative number, sqrt will throw a DomainError (because sqrt can't accept negative Real inputs). Of course, you forgot to add a call to abs before the call to sqrt! Now, you know how to fix this, but once you do, you'll have to spend another entire day waiting for it to finish! And maybe you fix this one bug and wait a full day for it to finish, and begin adding more very computationally-heavy code (which inevitably has bugs). Those later computations might fail, and if you're running this as a script (maybe under a cluster scheduler like Slurm), you have to restart everything from the very beginning. This is starting to sound pretty wasteful...","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Thankfully, Dagger has a simple solution to this: checkpointing. With checkpointing, Dagger can be instructed to save intermediate results (maybe the results of computing Y) to a persistent storage medium of your choice. Probably a file on disk, but maybe a database, or even just stored in RAM in a space-efficient form. You also tell Dagger how to restore this data: how to take the result stored in its persistent form, and turn it back into something identical to the original intermediate data that Dagger computed. Then, when the worst happens and a piece of your algorithm throws an error (as above), Dagger will call the restore function and try to materialize those intermediate results that you painstakingly computed, so that you don't need to re-compute them.","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Let's see how we'd modify the above example to use checkpointing:","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"using Serialization\nX = compute(randn(Blocks(128,128), 1024, 1024))\nY = [delayed(sum; options=Dagger.Sch.ThunkOptions(;\ncheckpoint=(thunk,result)->begin\n    open(\"checkpoint-$idx.bin\", \"w\") do io\n        serialize(io, collect(result))\n    end\nend, restore=(thunk)->begin\n    open(\"checkpoint-$idx.bin\", \"r\") do io\n        Dagger.tochunk(deserialize(io))\n    end\nend))(chunk) for (idx,chunk) in enumerate(X.chunks)]\ninner(x...) = sqrt(sum(x))\nZ = delayed(inner)(Y...)\nz = collect(Z)","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Two changes were made: first, we enumerate(X.chunks) so that we can get a unique index to identify each chunk; second, we specify a ThunkOptions to delayed with a checkpoint and restore function that is specialized to write or read the given chunk to or from a file on disk, respectively. Notice the usage of collect in the checkpoint function, and the use of Dagger.tochunk in the restore function; Dagger represents intermediate results as Dagger.Chunk objects, so we need to convert between Chunks and the actual data to keep Dagger happy. Performance-sensitive users might consider modifying these methods to store the checkpoint files on the filesystem of the server that currently owns the Chunk, to minimize data transfer times during checkpoint and restore operations.","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"If we run the above code once, we'll still end up waiting a day for Y to be computed, and we'll still get the DomainError from sqrt. However, when we fix the inner function to include that call to abs that was missing, and we re-run this code starting from the creation of Y, we'll find that we don't actually spend a day waiting; we probably spend a few seconds waiting, and end up with our final result! This is because Dagger called the restore function for each element of Y, and was provided a result by the user-specified function, so it skipped re-computing those sums entirely.","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"You might also notice that when you ran this code the first time, you received errors about \"No such file or directory\", or some similar error; this occurs because Dagger always calls the restore function when it exists. In the first run, the checkpoint files don't yet exist, so there's nothing to restore; Dagger reports the thrown error, but keeps moving along, merrily computing the sums of Y. You're welcome to explicitly check if the file exists, and if not, return nothing; then Dagger won't report an annoying error, and will skip the restoration quietly.","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Of course, you might have a lot of code that looks like this, and may want to also checkpoint the final result of the z = collect(...) call as well. This is just as easy to do:","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"# compute X, Y, Z above ...\nz = collect(Z; options=Dagger.Sch.SchedulerOptions(;\ncheckpoint=(result)->begin\n    open(\"checkpoint-final.bin\", \"w\") do io\n        serialize(io, collect(result))\n    end\nend, restore=()->begin\n    open(\"checkpoint-final.bin\", \"r\") do io\n        Dagger.tochunk(deserialize(io))\n    end\nend))","category":"page"},{"location":"checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"In this case, the entire computation will be skipped if checkpoint-final.bin exists!","category":"page"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"CurrentModule = Dagger","category":"page"},{"location":"api/functions/#Functions","page":"Functions and Macros","title":"Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"api/functions/#General-Functions","page":"Functions and Macros","title":"General Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"delayed\nspawn\ntochunk\ndomain\ncompute\ndependents\nnoffspring\norder\ntreereduce","category":"page"},{"location":"api/functions/#Dagger.delayed","page":"Functions and Macros","title":"Dagger.delayed","text":"delayed(f; kwargs...)(args...)\n\nCreates a Thunk object which can be executed later, which will call f with args. kwargs controls various properties of the resulting Thunk.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.spawn","page":"Functions and Macros","title":"Dagger.spawn","text":"spawn(f, args...; kwargs...) -> EagerThunk\n\nSpawns a task with f as the function and args as the arguments, returning an EagerThunk. Uses a scheduler running in the background to execute code.\n\nNote that kwargs are passed to the Thunk constructor, and are documented in its docstring.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.tochunk","page":"Functions and Macros","title":"Dagger.tochunk","text":"tochunk(x, proc::Processor, scope::AbstractScope; device=nothing, kwargs...) -> Chunk\n\nCreate a chunk from data x which resides on proc and which has scope scope.\n\ndevice specifies a MemPool.StorageDevice (which is itself wrapped in a Chunk) which will be used to manage the reference contained in the Chunk generated by this function. If device is nothing (the default), the data will be inspected to determine if it's safe to serialize; if so, the default MemPool storage device will be used; if not, then a MemPool.CPURAMDevice will be used.\n\nAll other kwargs are passed directly to MemPool.poolset.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.domain","page":"Functions and Macros","title":"Dagger.domain","text":"domain(x::T)\n\nReturns metadata about x. This metadata will be in the domain field of a Chunk object when an object of type T is created as the result of evaluating a Thunk.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.compute","page":"Functions and Macros","title":"Dagger.compute","text":"compute(ctx::Context, d::Thunk; options=nothing) -> Chunk\n\nCompute a Thunk - creates the DAG, assigns ranks to nodes for tie breaking and runs the scheduler with the specified options. Returns a Chunk which references the result.\n\n\n\n\n\ncompute(ctx::Context, x::DArray; persist=true, options=nothing)\n\nA DArray object may contain a thunk in it, in which case we first turn it into a Thunk and then compute it.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.dependents","page":"Functions and Macros","title":"Dagger.dependents","text":"dependents(node::Thunk) -> Dict{Union{Thunk,Chunk}, Set{Thunk}}\n\nFind the set of direct dependents for each task.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.noffspring","page":"Functions and Macros","title":"Dagger.noffspring","text":"noffspring(dpents::Dict{Union{Thunk,Chunk}, Set{Thunk}}) -> Dict{Thunk, Int}\n\nRecursively find the number of tasks dependent on each task in the DAG. Takes a Dict as returned by dependents.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.order","page":"Functions and Macros","title":"Dagger.order","text":"order(node::Thunk, ndeps) -> Dict{Thunk,Int}\n\nGiven a root node of the DAG, calculates a total order for tie-breaking.\n\nRoot node gets score 1,\nrest of the nodes are explored in DFS fashion but chunks of each node are explored in order of noffspring, i.e. total number of tasks depending on the result of the said node.\n\nArgs:\n\nnode: root node\nndeps: result of noffspring\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.treereduce","page":"Functions and Macros","title":"Dagger.treereduce","text":"Tree reduce\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Table-Functions","page":"Functions and Macros","title":"Table Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"tabletype\ntabletype!\ntrim\ntrim!\nmap\nfilter\nreduce\ngroupby\nleftjoin\ninnerjoin\nkeys\ngetindex","category":"page"},{"location":"api/functions/#Array-Functions","page":"Functions and Macros","title":"Array Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"alignfirst\nview","category":"page"},{"location":"api/functions/#Dagger.alignfirst","page":"Functions and Macros","title":"Dagger.alignfirst","text":"alignfirst(a) -> ArrayDomain\n\nMake a subdomain a standalone domain.\n\nExample\n\njulia> alignfirst(ArrayDomain(11:25, 21:100))\nArrayDomain((1:15), (1:80))\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Base.view","page":"Functions and Macros","title":"Base.view","text":"view(c::DArray, d)\n\nA view of a DArray chunk returns a DArray of Thunks.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Processor-Functions","page":"Functions and Macros","title":"Processor Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"execute!\niscompatible\ndefault_enabled\nget_processors\nget_parent\nmove\ncapacity\nget_tls\nset_tls!","category":"page"},{"location":"api/functions/#Dagger.execute!","page":"Functions and Macros","title":"Dagger.execute!","text":"execute!(proc::Processor, f, args...) -> Any\n\nExecutes the function f with arguments args on processor proc. This function can be overloaded by Processor subtypes to allow executing function calls differently than normal Julia.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.iscompatible","page":"Functions and Macros","title":"Dagger.iscompatible","text":"iscompatible(proc::Processor, opts, f, Targs...) -> Bool\n\nIndicates whether proc can execute f over Targs given opts. Processor subtypes should overload this function to return true if and only if it is essentially guaranteed that f(::Targs...) is supported. Additionally, iscompatible_func and iscompatible_arg can be overriden to determine compatibility of f and Targs individually. The default implementation returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.default_enabled","page":"Functions and Macros","title":"Dagger.default_enabled","text":"default_enabled(proc::Processor) -> Bool\n\nReturns whether processor proc is enabled by default. The default value is false, which is an opt-out of the processor from execution when not specifically requested by the user, and true implies opt-in, which causes the processor to always participate in execution when possible.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.get_processors","page":"Functions and Macros","title":"Dagger.get_processors","text":"get_processors(proc::Processor) -> Set{<:Processor}\n\nReturns the set of processors contained in proc, if any. Processor subtypes should overload this function if they can contain sub-processors. The default method will return a Set containing proc itself.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.get_parent","page":"Functions and Macros","title":"Dagger.get_parent","text":"get_parent(proc::Processor) -> Processor\n\nReturns the parent processor for proc. The ultimate parent processor is an OSProc. Processor subtypes should overload this to return their most direct parent.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.move","page":"Functions and Macros","title":"Dagger.move","text":"move(from_proc::Processor, to_proc::Processor, x)\n\nMoves and/or converts x such that it's available and suitable for usage on the to_proc processor. This function can be overloaded by Processor subtypes to transport arguments and convert them to an appropriate form before being used for exection. Subtypes of Processor wishing to implement efficient data movement should provide implementations where x::Chunk.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.get_tls","page":"Functions and Macros","title":"Dagger.get_tls","text":"get_tls()\n\nGets all Dagger TLS variable as a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.set_tls!","page":"Functions and Macros","title":"Dagger.set_tls!","text":"set_tls!(tls)\n\nSets all Dagger TLS variables from the NamedTuple tls.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Shard-Functions","page":"Functions and Macros","title":"Shard Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"Dagger.@shard Dagger.shard","category":"page"},{"location":"api/functions/#Context-Functions","page":"Functions and Macros","title":"Context Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"addprocs!\nrmprocs!","category":"page"},{"location":"api/functions/#Dagger.addprocs!","page":"Functions and Macros","title":"Dagger.addprocs!","text":"addprocs!(ctx::Context, xs)\n\nAdd new workers xs to ctx.\n\nWorkers will typically be assigned new tasks in the next scheduling iteration if scheduling is ongoing.\n\nWorkers can be either Processors or the underlying process IDs as Integers.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.rmprocs!","page":"Functions and Macros","title":"Dagger.rmprocs!","text":"rmprocs!(ctx::Context, xs)\n\nRemove the specified workers xs from ctx.\n\nWorkers will typically finish all their assigned tasks if scheduling is ongoing but will not be assigned new tasks after removal.\n\nWorkers can be either Processors or the underlying process IDs as Integers.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Logging-Functions","page":"Functions and Macros","title":"Logging Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"get_logs!","category":"page"},{"location":"api/functions/#Thunk-Execution-Environment-Functions","page":"Functions and Macros","title":"Thunk Execution Environment Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"These functions are used within the function called by a Thunk.","category":"page"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"in_thunk\nthunk_processor","category":"page"},{"location":"api/functions/#Dagger.in_thunk","page":"Functions and Macros","title":"Dagger.in_thunk","text":"in_thunk()\n\nReturns true if currently in a Thunk process, else false.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.thunk_processor","page":"Functions and Macros","title":"Dagger.thunk_processor","text":"thunk_processor()\n\nGet the current processor executing the current thunk.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dynamic-Scheduler-Control-Functions","page":"Functions and Macros","title":"Dynamic Scheduler Control Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"These functions query and control the scheduler remotely.","category":"page"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"Sch.sch_handle\nSch.add_thunk!\nBase.fetch\nBase.wait\nSch.exec!\nSch.halt!\nSch.get_dag_ids","category":"page"},{"location":"api/functions/#Dagger.Sch.sch_handle","page":"Functions and Macros","title":"Dagger.Sch.sch_handle","text":"Gets the scheduler handle for the currently-executing thunk.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.Sch.add_thunk!","page":"Functions and Macros","title":"Dagger.Sch.add_thunk!","text":"Adds a new Thunk to the DAG.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Base.fetch","page":"Functions and Macros","title":"Base.fetch","text":"Waits on a thunk to complete, and fetches its result.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Base.wait","page":"Functions and Macros","title":"Base.wait","text":"Waits on a thunk to complete.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.Sch.exec!","page":"Functions and Macros","title":"Dagger.Sch.exec!","text":"Executes an arbitrary function within the scheduler, returning the result.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.Sch.halt!","page":"Functions and Macros","title":"Dagger.Sch.halt!","text":"Commands the scheduler to halt execution immediately.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.Sch.get_dag_ids","page":"Functions and Macros","title":"Dagger.Sch.get_dag_ids","text":"Returns all Thunks IDs as a Dict, mapping a Thunk to its downstream dependents.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#File-IO-Functions","page":"Functions and Macros","title":"File IO Functions","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"warning: Warning\nThese APIs are currently untested and may be removed or modified.","category":"page"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"save\nload","category":"page"},{"location":"api/functions/#Dagger.save","page":"Functions and Macros","title":"Dagger.save","text":"save(io::IO, val)\n\nSave a value into the IO buffer. In the case of arrays and sparse matrices, this will save it in a memory-mappable way.\n\nload(io::IO, t::Type, domain) will load the object given its domain\n\n\n\n\n\nsave(ctx, chunk::Union{Chunk, Thunk}, file_path::AbsractString)\n\nSave a chunk to a file at file_path.\n\n\n\n\n\nsave(ctx, chunk, file_path)\n\nSpecial case distmem writing - write to disk on the process with the chunk.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Dagger.load","page":"Functions and Macros","title":"Dagger.load","text":"load(ctx::Context, file_path)\n\nLoad an Union{Chunk, Thunk} from a file.\n\n\n\n\n\nload(ctx::Context, ::Type{Chunk}, fpath, io)\n\nLoad a Chunk object from a file, the file path is required for creating a FileReader object\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Macros-API","page":"Functions and Macros","title":"Macros API","text":"","category":"section"},{"location":"api/functions/","page":"Functions and Macros","title":"Functions and Macros","text":"@par\n@spawn","category":"page"},{"location":"api/functions/#Dagger.@par","page":"Functions and Macros","title":"Dagger.@par","text":"@par [opts] f(args...) -> Thunk\n\nConvenience macro to call Dagger.delayed on f with arguments args. May also be called with a series of assignments like so:\n\nx = @par begin\n    a = f(1,2)\n    b = g(a,3)\n    h(a,b)\nend\n\nx will hold the Thunk representing h(a,b); additionally, a and b will be defined in the same local scope and will be equally accessible for later calls.\n\nOptions to the Thunk can be set as opts with namedtuple syntax, e.g. single=1. Multiple options may be provided, and will be applied to all generated thunks.\n\n\n\n\n\n","category":"macro"},{"location":"api/functions/#Dagger.@spawn","page":"Functions and Macros","title":"Dagger.@spawn","text":"@spawn [opts] f(args...) -> Thunk\n\nConvenience macro like Dagger.@par, but eagerly executed from the moment it's called (equivalent to spawn).\n\nSee the docs for @par for more information and usage examples.\n\n\n\n\n\n","category":"macro"},{"location":"benchmarking/#Benchmarking-Dagger","page":"Benchmarking","title":"Benchmarking Dagger","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"For ease of benchmarking changes to Dagger's scheduler and the DArray, a benchmarking script exists at benchmarks/benchmark.jl. This script currently allows benchmarking a non-negative matrix factorization (NNMF) algorithm, which we've found to be a good evaluator of scheduling performance. The benchmark script can test with and without Dagger, and also has support for using CUDA or AMD GPUs to accelerate the NNMF via DaggerGPU.jl.","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"The script checks for a number of environment variables, which are used to control the benchmarks that are performed (all of which are optional):","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"BENCHMARK_PROCS: Selects the number of Julia processes and threads to start-up. Specified as 8:4, this option would start 8 extra Julia processes, with 4 threads each. Defaults to 2 processors and 1 thread each.\nBENCHMARK_REMOTES: Specifies a colon-separated list of remote servers to connect to and start Julia processes on, using BENCHMARK_PROCS to indicate the processor/thread configuration of those remotes. Disabled by default (uses the local machine).\nBENCHMARK_OUTPUT_FORMAT: Selects the output format for benchmark results. Defaults to jls, which uses Julia's Serialization stdlib, and can also be jld to use JLD.jl.\nBENCHMARK_RENDER: Configures rendering, which is disabled by default. Can be \"live\" or \"offline\", which are explained below.\nBENCHMARK: Specifies the set of benchmarks to run as a comma-separated list, where each entry can be one of cpu, cuda, or amdgpu, and may optionally append +dagger (like cuda+dagger) to indicate whether or not to use Dagger. Defaults to cpu,cpu+dagger, which runs CPU benchmarks with and without Dagger.\nBENCHMARK_SCALE: Determines how much to scale the benchmark sizing by, typically specified as a UnitRange{Int}. Defaults to 1:5:50, which runs each scale from 1 to 50, in steps of 5.","category":"page"},{"location":"benchmarking/#Rendering-with-BENCHMARK_RENDER","page":"Benchmarking","title":"Rendering with BENCHMARK_RENDER","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Dagger contains visualization code for the scheduler (as a Gantt chart) and thunk execution profiling (flamechart), which can be enabled with BENCHMARK_RENDER. Additionally, rendering can be done \"live\", served via a Mux.jl webserver run locally, or \"offline\", where the visualization will be embedded into the results output file. By default, rendering is disabled. If BENCHMARK_RENDER is set to live, a Mux webserver is started at localhost:8000 (the address is not yet configurable), and the Gantt chart and profiling flamechart will be rendered once the benchmarks start. If set to offline, data visualization will happen in the background, and will be passed in the results file.","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Note that Gantt chart and flamechart output is only generated and relevant during Dagger execution.","category":"page"},{"location":"benchmarking/#TODO:-Plotting","page":"Benchmarking","title":"TODO: Plotting","text":"","category":"section"},{"location":"logging/#Logging-and-Graphing","page":"Logging and Graphing","title":"Logging and Graphing","text":"","category":"section"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"Dagger's scheduler keeps track of the important and potentially expensive actions it does, such as moving data between workers or executing thunks, and tracks how much time and memory allocations these operations consume, among other things. It does it through the TimespanLogging.jl package (which used to be directly integrated into Dagger). Saving this information somewhere accessible is disabled by default, but it's quite easy to turn it on, by setting a \"log sink\" in the Context being used, as ctx.log_sink. A variety of log sinks are built-in to TimespanLogging; the NoOpLog is the default log sink when one isn't explicitly specified, and disables logging entirely (to minimize overhead). There are currently two other log sinks of interest; the first and newer of the two is the MultiEventLog, which generates multiple independent log streams, one per \"consumer\" (details in the next section). The second and older sink is the LocalEventLog, which is explained later in this document. Most users are recommended to use the MultiEventLog since it's far more flexible and extensible, and is more performant in general.","category":"page"},{"location":"logging/#MultiEventLog","page":"Logging and Graphing","title":"MultiEventLog","text":"","category":"section"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"The MultiEventLog is intended to be configurable to exclude unnecessary information, and to include any built-in or user-defined metrics. It stores a set of \"sub-log\" streams internally, appending a single element to each of them when an event is generated. This element can be called a \"sub-event\" (to distinguish it from the higher-level \"event\" that Dagger creates), and is created by a \"consumer\". A consumer is a function or callable struct that, when called with the Event object generated by TimespanLogging, returns a sub-event characterizing whatever information the consumer represents. For example, the Dagger.Events.BytesAllocd consumer calculates the total bytes allocated and live at any given time within Dagger, and returns the current value when called. Let's construct one:","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"ctx = Context()\nml = TimspanLogging.MultiEventLog()\n\n# Add the BytesAllocd consumer to the log as `:bytes`\nml[:bytes] = Dagger.Events.BytesAllocd()\n\nctx.log_sink = ml","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"As we can see above, each consumer gets a unique name as a Symbol that identifies it. Now that the log sink is attached with a consumer, we can execute some Dagger tasks, and then collect the sub-events generated by BytesAllocd:","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"# Using the lazy API, for explanatory purposes\ncollect(ctx, delayed(+)(1, delayed(*)(3, 4))) # Allocates 8 bytes\nlog = TimspanLogging.get_logs!(ctx)[1] # Get the logs for worker 1\n@show log[:bytes]","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"You'll then see that 8 bytes are allocated and then freed during the process of executing and completing those tasks.","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"Note that the MultiEventLog can also be used perfectly well when using Dagger's eager API:","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"ctx = Dagger.Sch.eager_context()\nctx.log_sink = ml\n\na = Dagger.@spawn 3*4\nDagger.@spawn 1+a","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"There are a variety of other consumers built-in to TimespanLogging and Dagger, under the TimespanLogging.Events and Dagger.Events modules, respectively:","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"TimespanLogging.Events.CoreMetrics\nTimespanLogging.Events.IDMetrics\nTimespanLogging.Events.TimelineMetrics\nTimespanLogging.Events.FullMetrics\nTimespanLogging.Events.CPULoadAverages\nTimespanLogging.Events.MemoryFree\nTimespanLogging.Events.EventSaturation\nTimespanLogging.Events.WorkerSaturation\nDagger.Events.BytesAllocd\nDagger.Events.ProcessorSaturation","category":"page"},{"location":"logging/#Dagger.Events.BytesAllocd","page":"Logging and Graphing","title":"Dagger.Events.BytesAllocd","text":"BytesAllocd\n\nTracks memory allocated for Chunks.\n\n\n\n\n\n","category":"type"},{"location":"logging/#Dagger.Events.ProcessorSaturation","page":"Logging and Graphing","title":"Dagger.Events.ProcessorSaturation","text":"ProcessorSaturation\n\nTracks the compute saturation (running tasks) per-processor.\n\n\n\n\n\n","category":"type"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"The MultiEventLog also has a mechanism to call a set of functions, called \"aggregators\", after all consumers have been executed, and are passed the full set of log streams as a Dict{Symbol,Vector{Any}}. The only one currently shipped with TimespanLogging directly is the LogWindow, and DaggerWebDash.jl has the TableStorage which integrates with it:","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"Timespan.Events.LogWindow\nDaggerWebDash.TableStorage","category":"page"},{"location":"logging/#LocalEventLog","page":"Logging and Graphing","title":"LocalEventLog","text":"","category":"section"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"The LocalEventLog is generally only useful when you want combined events (event start and finish combined as a single unit), and only care about a few simple built-in generated events. Let's attach one to our context:","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"ctx = Context()\nlog = TimespanLogging.LocalEventLog()\nctx.log_sink = log","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"Now anytime ctx is used as the context for a scheduler, the scheduler will log events into log.","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"Once sufficient data has been accumulated into a LocalEventLog, it can be gathered to a single host via TimespanLogging.get_logs!(log). The result is a Vector of TimespanLogging.Timespan objects, which describe some metadata about an operation that occured and the scheduler logged. These events may be introspected directly, or may also be rendered to a DOT-format string:","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"logs = TimespanLogging.get_logs!(log)\nstr = Dagger.show_plan(logs)","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"Dagger.show_plan can also be called as Dagger.show_plan(io::IO, logs) to write the graph to a file or other IO object. The string generated by this function may be passed to an external tool like Graphviz for rendering. Note that this method doesn't display input arguments to the DAG (non-Thunks); you can call Dagger.show_plan(logs, thunk), where thunk is the output Thunk of the DAG, to render argument nodes.","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"note: Note\nTimespanLogging.get_logs! clears out the event logs, so that old events don't mix with new ones from future DAGs.","category":"page"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"As a convenience, it's possible to set ctx.log_file to the path to an output file, and then calls to compute(ctx, ...)/collect(ctx, ...) will automatically write the graph in DOT format to that path. There is also a benefit to this approach over manual calls to get_logs! and show_plan: DAGs which aren't Thunks (such as operations on the Dagger.DArray) will be properly rendered with input arguments (which normally aren't rendered because a Thunk is dynamically generated from such operations by Dagger before scheduling).","category":"page"},{"location":"logging/#FilterLog","page":"Logging and Graphing","title":"FilterLog","text":"","category":"section"},{"location":"logging/","page":"Logging and Graphing","title":"Logging and Graphing","text":"The FilterLog exists to allow writing events to a user-defined location (such as a database, file, or network socket). It is not currently tested or documented.","category":"page"},{"location":"api/types/","page":"Types","title":"Types","text":"CurrentModule = Dagger","category":"page"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"api/types/#General-Types","page":"Types","title":"General Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Thunk\nEagerThunk\nChunk\nUnitDomain","category":"page"},{"location":"api/types/#Dagger.Thunk","page":"Types","title":"Dagger.Thunk","text":"Thunk\n\nWraps a callable object to be run with Dagger. A Thunk is typically created through a call to delayed or its macro equivalent @par.\n\nConstructors\n\ndelayed(f; kwargs...)(args...)\n@par [option=value]... f(args...)\n\nExamples\n\njulia> t = delayed(sin)(π)  # creates a Thunk to be computed later\nThunk(sin, (π,))\n\njulia> collect(t)  # computes the result and returns it to the current process\n1.2246467991473532e-16\n\nArguments\n\nf: The function to be called upon execution of the Thunk.\nargs: The arguments to be passed to the Thunk.\nkwargs: The properties describing unique behavior of this Thunk. Details\n\nfor each property are described in the next section.\n\noption=value: The same as passing kwargs to delayed.\n\nPublic Properties\n\nmeta::Bool=false: If true, instead of fetching cached arguments from\n\nChunks and passing the raw arguments to f, instead pass the Chunk. Useful for doing manual fetching or manipulation of Chunk references. Non-Chunk arguments are still passed as-is.\n\nprocessor::Processor=OSProc() - The processor associated with f. Useful if\n\nf is a callable struct that exists on a given processor and should be transferred appropriately.\n\nscope::Dagger.AbstractScope=AnyScope() - The scope associated with f.\n\nUseful if f is a function or callable struct that may only be transferred to, and executed within, the specified scope.\n\nOptions\n\noptions: A Sch.ThunkOptions struct providing the options for the Thunk.\n\nIf omitted, options can also be specified by passing key-value pairs as kwargs.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.EagerThunk","page":"Types","title":"Dagger.EagerThunk","text":"EagerThunk\n\nReturned from spawn/@spawn calls. Represents a task that is in the scheduler, potentially ready to execute, executing, or finished executing. May be fetch'd or wait'd on at any time.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.Chunk","page":"Types","title":"Dagger.Chunk","text":"Chunk\n\nA reference to a piece of data located on a remote worker. Chunks are typically created with Dagger.tochunk(data), and the data can then be accessed from any worker with collect(::Chunk). Chunks are serialization-safe, and use distributed refcounting (provided by MemPool.DRef) to ensure that the data referenced by a Chunk won't be GC'd, as long as a reference exists on some worker.\n\nEach Chunk is associated with a given Dagger.Processor, which is (in a sense) the processor that \"owns\" or contains the data. Calling collect(::Chunk) will perform data movement and conversions defined by that processor to safely serialize the data to the calling worker.\n\nConstructors\n\nSee tochunk.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.UnitDomain","page":"Types","title":"Dagger.UnitDomain","text":"UnitDomain\n\nDefault domain – has no information about the value\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Array-Types","page":"Types","title":"Array Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"DArray\nBlocks\nArrayDomain","category":"page"},{"location":"api/types/#Dagger.DArray","page":"Types","title":"Dagger.DArray","text":"DArray{T,N,F}(domain, subdomains, chunks, concat)\nDArray(T, domain, subdomains, chunks, [concat=cat])\n\nAn N-dimensional distributed array of element type T, with a concatenation function of type F.\n\nArguments\n\nT: element type\ndomain::ArrayDomain{N}: the whole ArrayDomain of the array\nsubdomains::AbstractArray{ArrayDomain{N}, N}: a DomainBlocks of the same dimensions as the array\nchunks::AbstractArray{Union{Chunk,Thunk}, N}: an array of chunks of dimension N\nconcat::F: a function of type F. concat(x, y; dims=d) takes two chunks x and y and concatenates them along dimension d. cat is used by default.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.Blocks","page":"Types","title":"Dagger.Blocks","text":"Blocks(xs...)\n\nIndicates the size of an array operation, specified as xs, whose length indicates the number of dimensions in the resulting array.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.ArrayDomain","page":"Types","title":"Dagger.ArrayDomain","text":"ArrayDomain{N}\n\nAn N-dimensional domain over an array.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Processor-Types","page":"Types","title":"Processor Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Processor\nOSProc\nThreadProc","category":"page"},{"location":"api/types/#Dagger.Processor","page":"Types","title":"Dagger.Processor","text":"Processor\n\nAn abstract type representing a processing device and associated memory, where data can be stored and operated on. Subtypes should be immutable, and instances should compare equal if they represent the same logical processing device/memory. Subtype instances should be serializable between different nodes. Subtype instances may contain a \"parent\" Processor to make it easy to transfer data to/from other types of Processor at runtime.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.OSProc","page":"Types","title":"Dagger.OSProc","text":"OSProc <: Processor\n\nJulia CPU (OS) process, identified by Distributed pid. The logical parent of all processors on a given node, but otherwise does not participate in computations.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.ThreadProc","page":"Types","title":"Dagger.ThreadProc","text":"ThreadProc <: Processor\n\nJulia CPU (OS) thread, identified by Julia thread ID.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Scope-Types","page":"Types","title":"Scope Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"AnyScope\nNodeScope\nProcessScope\nUnionScope\nExactScope","category":"page"},{"location":"api/types/#Dagger.AnyScope","page":"Types","title":"Dagger.AnyScope","text":"Default scope that is unconstrained.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.NodeScope","page":"Types","title":"Dagger.NodeScope","text":"Scoped to the same physical node.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.ProcessScope","page":"Types","title":"Dagger.ProcessScope","text":"Scoped to the same OS process.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.UnionScope","page":"Types","title":"Dagger.UnionScope","text":"Union of two or more scopes.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.ExactScope","page":"Types","title":"Dagger.ExactScope","text":"Scoped to a specific processor.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Context-Types","page":"Types","title":"Context Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Context","category":"page"},{"location":"api/types/#Dagger.Context","page":"Types","title":"Dagger.Context","text":"Context(xs::Vector{OSProc}) -> Context\nContext(xs::Vector{Int}) -> Context\n\nCreate a Context, by default adding each available worker.\n\nIt is also possible to create a Context from a vector of OSProc, or equivalently the underlying process ids can also be passed directly as a Vector{Int}.\n\nSpecial fields include:\n\n'log_sink': A log sink object to use, if any.\nlog_file::Union{String,Nothing}: Path to logfile. If specified, at\n\nscheduler termination, logs will be collected, combined with input thunks, and written out in DOT format to this location.\n\nprofile::Bool: Whether or not to perform profiling with Profile stdlib.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Logging-Types","page":"Types","title":"Logging Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"NoOpLog\nLocalEventLog","category":"page"},{"location":"api/types/#Scheduling-Types","page":"Types","title":"Scheduling Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Sch.SchedulerOptions\nSch.ThunkOptions\nSch.MaxUtilization\nSch.DynamicThunkException","category":"page"},{"location":"api/types/#Dagger.Sch.SchedulerOptions","page":"Types","title":"Dagger.Sch.SchedulerOptions","text":"SchedulerOptions\n\nStores DAG-global options to be passed to the Dagger.Sch scheduler.\n\nArguments\n\nsingle::Int=0: Force all work onto worker with specified id. 0 disables\n\nthis option.\n\nproclist=nothing: Force scheduler to use one or more processors that are\n\ninstances/subtypes of a contained type. Alternatively, a function can be supplied, and the function will be called with a processor as the sole argument and should return a Bool result to indicate whether or not to use the given processor. nothing enables all default processors.\n\nallow_errors::Bool=true: Allow thunks to error without affecting\n\nnon-dependent thunks.\n\ncheckpoint=nothing: If not nothing, uses the provided function to save\n\nthe final result of the current scheduler invocation to persistent storage, for later retrieval by restore.\n\nrestore=nothing: If not nothing, uses the provided function to return the\n\n(cached) final result of the current scheduler invocation, were it to execute. If this returns a Chunk, all thunks will be skipped, and the Chunk will be returned.  If nothing is returned, restoring is skipped, and the scheduler will execute as usual. If this function throws an error, restoring will be skipped, and the error will be displayed.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.Sch.ThunkOptions","page":"Types","title":"Dagger.Sch.ThunkOptions","text":"ThunkOptions\n\nStores Thunk-local options to be passed to the Dagger.Sch scheduler.\n\nArguments\n\nsingle::Int=0: Force thunk onto worker with specified id. 0 disables this\n\noption.\n\nproclist=nothing: Force thunk to use one or more processors that are\n\ninstances/subtypes of a contained type. Alternatively, a function can be supplied, and the function will be called with a processor as the sole argument and should return a Bool result to indicate whether or not to use the given processor. nothing enables all default processors.\n\ntime_util::Dict{Type,Any}=Dict{Type,Any}(): Indicates the maximum expected\n\ntime utilization for this thunk. Each keypair maps a processor type to the utilization, where the value can be a real (approximately the number of nanoseconds taken), or MaxUtilization() (utilizes all processors of this type). By default, the scheduler assumes that this thunk only uses one processor.\n\nalloc_util::Dict{Type,UInt64}=Dict{Type,UInt64}(): Indicates the maximum\n\nexpected memory utilization for this thunk. Each keypair maps a processor type to the utilization, where the value is an integer representing approximately the maximum number of bytes allocated at any one time.\n\nallow_errors::Bool=true: Allow this thunk to error without affecting\n\nnon-dependent thunks.\n\ncheckpoint=nothing: If not nothing, uses the provided function to save\n\nthe result of the thunk to persistent storage, for later retrieval by restore.\n\nrestore=nothing: If not nothing, uses the provided function to return the\n\n(cached) result of this thunk, were it to execute.  If this returns a Chunk, this thunk will be skipped, and its result will be set to the Chunk.  If nothing is returned, restoring is skipped, and the thunk will execute as usual. If this function throws an error, restoring will be skipped, and the error will be displayed.\n\nstorage::Union{Chunk,Nothing}=nothing: If not nothing, references a\n\nMemPool.StorageDevice which will be passed to MemPool.poolset internally when constructing Chunks (such as when constructing the return value). The device must support MemPool.CPURAMResource. When nothing, uses MemPool.GLOBAL_DEVICE[].\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.Sch.MaxUtilization","page":"Types","title":"Dagger.Sch.MaxUtilization","text":"MaxUtilization\n\nIndicates a thunk that uses all processors of a given type.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Dagger.Sch.DynamicThunkException","page":"Types","title":"Dagger.Sch.DynamicThunkException","text":"Thrown when a dynamic thunk encounters an exception in Dagger's utilities.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#File-IO-Types","page":"Types","title":"File IO Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"warning: Warning\nThese APIs are currently untested and may be removed or modified.","category":"page"},{"location":"api/types/","page":"Types","title":"Types","text":"FileReader","category":"page"},{"location":"api/types/#Dagger.FileReader","page":"Types","title":"Dagger.FileReader","text":"FileReader\n\nUsed as a Chunk handle for reading a file, starting at a given offset.\n\n\n\n\n\n","category":"type"},{"location":"scopes/#Scopes","page":"Scopes","title":"Scopes","text":"","category":"section"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"Sometimes you will have data that is only meaningful in a certain location, such as within a single Julia process, a given server, or even for a specific Dagger processor. We call this location a \"scope\" in Dagger, denoting the bounds within which the data is meaningful and valid. For example, C pointers are typically scoped to a process, file paths are scoped to one or more servers dependent on filesystem configuration, etc. By default, Dagger doesn't recognize this; it treats everything passed into a task, or generated from a task, as inherently safe to transfer anywhere else. When this is not the case, Dagger provides optional scopes to instruct the scheduler where data is considered valid.","category":"page"},{"location":"scopes/#Scope-Basics","page":"Scopes","title":"Scope Basics","text":"","category":"section"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"Let's take the example of a webcam handle generated by VideoIO.jl. This handle is a C pointer, and thus has process scope. We can open the handle on a given process, and set the scope of the resulting data to a ProcessScope(), which defaults to the current Julia process:","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"using VideoIO\n\nfunction get_handle()\n    handle = VideoIO.opencamera()\n    proc = Dagger.thunk_processor()\n    scope = ProcessScope()\n    return Dagger.tochunk(handle, proc, scope)\nend\n\ncam_handle = Dagger.@spawn get_handle()","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"Now, wherever cam_handle is passed, Dagger will ensure that any computations on the handle only happen within its defined scope. For example, we can read from the camera:","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"cam_frame = Dagger.@spawn read(cam_handle)","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"The cam_frame task is executed within any processor on the same process that the cam_handle task was executed on. Of course, the resulting camera frame is not scoped to anywhere specific (denoted as AnyScope()), and thus computations on it may execute anywhere.","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"You may also encounter situations where you want to use a callable struct (such as a closure, or a Flux.jl layer) only within a certain scope; you can specify the scope of the function pretty easily:","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"using Flux\nm = Chain(...)\n# If `m` is only safe to transfer to and execute on this process,\n# we can set a `ProcessScope` on it:\nresult = Dagger.@spawn scope=ProcessScope() m(rand(8,8))","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"Setting a scope on the function treats it as a regular piece of data (like the arguments to the function), so it participates in the scoping rules described in the following sections all the same.","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"Now, let's try out some other kinds of scopes, starting with NodeScope. This scope encompasses the server that one or more Julia processes may be running on. Say we want to use memory mapping (mmap) to more efficiently send arrays between two tasks. We can construct the mmap'd array in one task, attach a NodeScope() to it, and using the path of the mmap'd file to communicate its location, lock downstream tasks to the same server:","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"using Mmap\n\nfunction generate()\n    path = \"myfile.bin\"\n    arr = Mmap.mmap(path, Matrix{Int}, (64,64))\n    fill!(arr, 1)\n    Mmap.sync!(arr)\n    Dagger.tochunk(path, Dagger.thunk_processor(), NodeScope())\nend\n\nfunction consume(path)\n    arr = Mmap.mmap(path, Matrix{Int}, (64,64))\n    sum(arr)\nend\n\na = Dagger.@spawn generate()\n@assert fetch(Dagger.@spawn consume(a)) == 64*64","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"Whatever server a executed on, b will also execute on!","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"Finally, we come to the \"lowest\" scope on the scope hierarchy, the ExactScope. This scope specifies one exact processor as the bounding scope, and is typically useful in certain limited cases. We won't provide an example here, because you don't usually need to ever use this scope, but if you already understand the NodeScope and ProcessScope, the ExactScope should be easy to figure out.","category":"page"},{"location":"scopes/#Union-Scopes","page":"Scopes","title":"Union Scopes","text":"","category":"section"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"Sometimes one simple scope isn't enough! In that case, you can use the UnionScope to construct the union of two or more scopes. Say, for example, you have some sensitive data on your company's servers that you want to compute summaries of, but you'll be driving the computation from your laptop, and you aren't allowed to send the data itself outside of the company's network. You could accomplish this by constructing a UnionScope of ProcessScopes of each of the non-laptop Julia processes, and use that to ensure that the data in its original form always stays within the company network:","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"addprocs(4) # some local processors\nprocs = addprocs([(\"server.company.com\", 4)]) # some company processors\n\nsecrets_scope = UnionScope(ProcessScope.(procs))\n\nfunction generate_secrets()\n    secrets = open(\"/shared/secret_results.txt\", \"r\") do io\n        String(read(io))\n    end\n    Dagger.tochunk(secrets, Dagger.thunk_processor(), secrets_scope)\nend\n\nsummarize(secrets) = occursin(\"QA Pass\", secrets)\n\n# Generate the data on the first company process\nsensitive_data = Dagger.@spawn single=first(procs) generate_secrets()\n\n# We can safely call this, knowing that it will be executed on a company server\nqa_passed = Dagger.@spawn summarize(sensitive_data)","category":"page"},{"location":"scopes/#Mismatched-Scopes","page":"Scopes","title":"Mismatched Scopes","text":"","category":"section"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"You might now be thinking, \"What if I want to run a task on multiple pieces of data whose scopes don't match up?\" In such a case, Dagger will throw an error, refusing to schedule that task, since the intersection of the data scopes is an empty set (there is no feasible processor which can satisfy the scoping constraints). For example:","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"ps2 = ProcessScope(2)\nps3 = ProcessScope(3)\n\ngenerate(scope) = Dagger.tochunk(rand(64), Dagger.thunk_processor(), scope)\n\nd2 = Dagger.@spawn generate(ps2) # Run on process 2\nd3 = Dagger.@spawn generate(ps3) # Run on process 3\nres = Dagger.@spawn d2 * d3 # An error!","category":"page"},{"location":"scopes/","page":"Scopes","title":"Scopes","text":"Moral of the story: only use scopes when you know you really need them, and if you aren't careful to arrange everything just right, be prepared for Dagger to refuse to schedule your tasks! Scopes should only be used to ensure correctness of your programs, and are not intended to be used to optimize the schedule that Dagger uses for your tasks, since restricting the scope of execution for tasks will necessarily reduce the optimizations that Dagger's scheduler can perform.","category":"page"},{"location":"processors/#Processors","page":"Processors","title":"Processors","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"Dagger contains a flexible mechanism to represent CPUs, GPUs, and other devices that the scheduler can place user work on. The individual devices that are capable of computing a user operation are called \"processors\", and are subtypes of Dagger.Processor. Processors are automatically detected by Dagger at scheduler initialization, and placed in a hierarchy reflecting the physical (network-, link-, or memory-based) boundaries between processors in the hierarchy. The scheduler uses the information in this hierarchy to efficiently schedule and partition user operations.","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"Dagger's Chunk objects can have a processor associated with them that defines where the contained data \"resides\". Each processor has a set of functions that define the mechanisms and rules by which the data can be transferred between similar or different kinds of processors, and will be called by Dagger's scheduler automatically when fetching function arguments (or the function itself) for computation on a given processor.","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"Setting the processor on a function argument is done by wrapping it in a Chunk with Dagger.tochunk:","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"a = 1\nb = 2\n# Let's say `b` \"resides\" on the second thread of the first worker:\nb_chunk = Dagger.tochunk(b, Dagger.ThreadProc(1, 2))::Dagger.Chunk\nc = Dagger.@spawn a + b_chunk\nfetch(c) == 3","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"It's also simple to set the processor of the function being passed; it will be automatically wrapped in a Chunk if necessary:","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"# `+` is treated as existing on the second thread of the first worker:\nDagger.@spawn processor=Dagger.ThreadProc(1, 2) a + b","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"You can also tell Dagger about the processor type for the returned value of a task by making it a Chunk:","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"Dagger.spawn(a) do a\n    c = a + 1\n    return Dagger.tochunk(c, Dagger.ThreadProc(1, 2))\nend","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"Note that unless you know that your function, arguments, or return value are associated with a specific processor, you don't need to assign one to them. Dagger will treat them as being simple values with no processor association, and will serialize them to wherever they're used.","category":"page"},{"location":"processors/#Hardware-capabilities,-topology,-and-data-locality","page":"Processors","title":"Hardware capabilities, topology, and data locality","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"The processor hierarchy is modeled as a multi-root tree, where each root is an OSProc, which represents a Julia OS process, and the \"children\" of the root or some other branch in the tree represent the processors which reside on the same logical server as the \"parent\" branch. All roots are connected to each other directly, in the common case. The processor hierarchy's topology is automatically detected and elaborated by callbacks in Dagger, which users may manipulate to add detection of extra processors.","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"A move between a given pair of processors is implemented as a Julia function dispatching on the types of each processor, as well as the type of the data being moved. Users are permitted to define custom move functions to improve data movement efficiency, perform automatic value conversions, or even make use of special IPC facilities. Custom processors may also be defined by the user to represent a processor type which is not automatically detected by Dagger, such as novel GPUs, special OS process abstractions, FPGAs, etc.","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"Movement of data between any two processors A and B (from A to B), if not defined by the user, is decomposed into 3 moves: processor A to OSProc parent of A, OSProc parent of A to OSProc parent of B, and OSProc parent of B to processor B. This mechanism uses Julia's Serialization library to serialize and deserialize data, so data must be serializable for this mechanism to work properly.","category":"page"},{"location":"processors/#Future:-Hierarchy-Generic-Path-Move","page":"Processors","title":"Future: Hierarchy Generic Path Move","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"NOTE: This used to be the default move behavior, but was removed because it wasn't considered helpful, and there were not any processor implementations that made use of it.","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"Movement of data between any two processors is decomposable into a sequence of \"moves\" between a child and its parent, termed a \"generic path move\". Movement of data may also take \"shortcuts\" between nodes in the tree which are not directly connected if enabled by libraries or the user, which may make use of IPC mechanisms to transfer data more directly and efficiently (such as Infiniband, GPU RDMA, NVLINK, etc.). All data is considered local to some processor, and may only be operated on by another processor by first doing an explicit move operation to that processor.","category":"page"},{"location":"processors/#Processor-Selection","page":"Processors","title":"Processor Selection","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"By default, Dagger uses the CPU to process work, typically single-threaded per cluster node. However, Dagger allows access to a wider range of hardware and software acceleration techniques, such as multithreading and GPUs. These more advanced (but performant) accelerators are disabled by default, but can easily be enabled by using Scheduler/Thunk options in the proclist field. If nothing, all default processors will be used. If a vector of types, only the processor types contained in options.proclist will be used to compute all or a given thunk. If a function, it will be called for each processor (with the processor as the argument) until it returns true.","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"opts = Dagger.Sch.ThunkOptions(;proclist=nothing) # default behavior\n# OR\nopts = Dagger.Sch.ThunkOptions(;proclist=[DaggerGPU.CuArrayProc]) # only execute on CuArrayProc\n# OR\nopts = Dagger.Sch.ThunkOptions(;proclist=(proc)->(proc isa Dagger.ThreadProc && proc.tid == 3)) # only run on ThreadProc with thread ID 3\n\nt = Dagger.@par options=opts sum(X) # do sum(X) on the specified processor","category":"page"},{"location":"processors/#Resource-Control","page":"Processors","title":"Resource Control","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"Dagger assumes that a thunk executing on a processor, fully utilizes that processor at 100%. When this is not the case, you can tell Dagger as much with options.procutil:","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"procutil = Dict(\n    Dagger.ThreadProc => 4.0, # utilizes 4 CPU threads fully\n    DaggerGPU.CuArrayProc => 0.1 # utilizes 10% of a single CUDA GPU\n)","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"Dagger will use this information to execute only as many thunks on a given processor (or set of similar processors) as add up to less than or equal to 1.0 total utilization. If a thunk is scheduled onto a processor which the local worker deems as \"oversubscribed\", it will not execute the thunk until sufficient resources become available by thunks completing execution.","category":"page"},{"location":"processors/#GPU-Processors","page":"Processors","title":"GPU Processors","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"The DaggerGPU.jl package can be imported to enable GPU acceleration for NVIDIA and AMD GPUs, when available. The processors provided by that package are not enabled by default, but may be enabled via options.proclist as usual.","category":"page"},{"location":"processors/#Future:-Network-Devices-and-Topology","page":"Processors","title":"Future: Network Devices and Topology","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"In the future, users will be able to define network devices attached to a given processor, which provides a direct connection to a network device on another processor, and may be used to transfer data between said processors. Data movement rules will most likely be defined by a similar (or even identical) mechanism to the current processor move mechanism. The multi-root tree will be expanded to a graph to allow representing these network devices (as they may potentially span non-root nodes).","category":"page"},{"location":"processors/#Redundancy","page":"Processors","title":"Redundancy","text":"","category":"section"},{"location":"processors/#Fault-Tolerance","page":"Processors","title":"Fault Tolerance","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"Dagger has a single means for ensuring redundancy, which is currently called \"fault tolerance\". Said redundancy is only targeted at a specific failure mode, namely the unexpected exit or \"killing\" of a worker process in the cluster. This failure mode often presents itself when running on a Linux and generating large memory allocations, where the Out Of Memory (OOM) killer process can kill user processes to free their allocated memory for the Linux kernel to use. The fault tolerance system mitigates the damage caused by the OOM killer performing its duties on one or more worker processes by detecting the fault as a process exit exception (generated by Julia), and then moving any \"lost\" work to other worker processes for re-computation.","category":"page"},{"location":"processors/#Future:-Multi-master,-Network-Failure-Correction,-etc.","page":"Processors","title":"Future: Multi-master, Network Failure Correction, etc.","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"This single redundancy mechanism helps alleviate a common issue among HPC and scientific users, however it does little to help when, for example, the master node exits, or a network link goes down. Such failure modes require a more complicated detection and recovery process, including multiple master processes, a distributed and replicated database such as etcd, and checkpointing of the scheduler to ensure an efficient recovery. Such a system does not yet exist, but contributions for such a change are desired.","category":"page"},{"location":"processors/#Dynamic-worker-pools","page":"Processors","title":"Dynamic worker pools","text":"","category":"section"},{"location":"processors/","page":"Processors","title":"Processors","text":"Dagger's default scheduler supports modifying the worker pool while the scheduler is running. This is done by modifying the Processors of the Context supplied to the scheduler at initialization using addprocs!(ctx, ps) and rmprocs(ctx, ps) where ps can be Processors or just process ids.","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"An example of when this is useful is in HPC environments where individual jobs to start up workers are queued so that not all workers are guaranteed to be available at the same time.","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"New workers will typically be assigned new tasks as soon as the scheduler sees them. Removed workers will finish all their assigned tasks but will not be assigned any new tasks. Note that this makes it difficult to determine when a worker is no longer in use by Dagger. Contributions to alleviate this uncertainty are welcome!","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"Example:","category":"page"},{"location":"processors/","page":"Processors","title":"Processors","text":"using Distributed\n\nps1 = addprocs(2, exeflags=\"--project\")\n@everywhere using Distributed, Dagger\n\n# Dummy task to wait for 0.5 seconds and then return the id of the worker\nts = delayed(vcat)((delayed(i -> (sleep(0.5); myid()))(i) for i in 1:20)...)\n\nctx = Context()\n# Scheduler is blocking, so we need a new task to add workers while it runs\njob = @async collect(ctx, ts)\n\n# Lets fire up some new workers\nps2 = addprocs(2, exeflags=\"--project\")\n@everywhere ps2 using Distributed, Dagger\n# New workers are not available until we do this\naddprocs!(ctx, ps2)\n\n# Lets hope the job didn't complete before workers were added :)\n@show fetch(job) |> unique\n\n# and cleanup after ourselves...\nworkers() |> rmprocs","category":"page"},{"location":"#A-framework-for-out-of-core-and-parallel-execution","page":"Home","title":"A framework for out-of-core and parallel execution","text":"","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main function for using Dagger is spawn:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dagger.spawn(f, args...; options...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or @spawn for the more convenient macro form:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dagger.@spawn [option=value]... f(args...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"When called, it creates an EagerThunk (also known as a \"thunk\" or \"task\") object representing a call to function f with the arguments args. If it is called with other thunks as inputs, such as in Dagger.@spawn f(Dagger.@spawn g()), then the function f gets passed the results of those input thunks. If those thunks aren't yet finished executing, then the execution of f waits on all of its input thunks to complete before executing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The key point is that, for each argument to a thunk, if the argument is an EagerThunk, it'll be executed before this node and its result will be passed into the function f. If the argument is not an EagerThunk (instead, some other type of Julia object), it'll be passed as-is to the function f.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thunks don't accept regular keyword arguments for the function f. Instead, the options kwargs are passed to the scheduler to control its behavior:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Any field in Dagger.Sch.ThunkOptions (see Scheduler and Thunk options)\nmeta::Bool – Pass the input Chunk objects themselves to f and not the value contained in them","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are also some extra kwargs that can be passed, although they're considered advanced options to be used only by developers or library authors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_result::Bool – return the actual result to the scheduler instead of Chunk objects. Used when f explicitly constructs a Chunk or when return value is small (e.g. in case of reduce)\npersist::Bool – the result of this Thunk should not be released after it becomes unused in the DAG\ncache::Bool – cache the result of this Thunk such that if the thunk is evaluated again, one can just reuse the cached value. If it’s been removed from cache, recompute the value.","category":"page"},{"location":"#Simple-example","page":"Home","title":"Simple example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's see a very simple directed acyclic graph (or DAG) constructed with Dagger:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dagger\n\nadd1(value) = value + 1\nadd2(value) = value + 2\ncombine(a...) = sum(a)\n\np = Dagger.@spawn add1(4)\nq = Dagger.@spawn add2(p)\nr = Dagger.@spawn add1(3)\ns = Dagger.@spawn combine(p, q, r)\n\n@assert fetch(s) == 16","category":"page"},{"location":"","page":"Home","title":"Home","text":"The thunks p, q, r, and s have the following structure:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: graph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The final result (from fetch(s)) is the obvious consequence of the operation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add1(4) + add2(add1(4)) + add1(3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(4 + 1) + ((4 + 1) + 2) + (3 + 1) == 16","category":"page"},{"location":"#Eager-Execution","page":"Home","title":"Eager Execution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dagger's @spawn macro works similarly to @async and Threads.@spawn: when called, it wraps the function call specified by the user in an EagerThunk object, and immediately places it onto a running scheduler, to be executed once its dependencies are fulfilled.","category":"page"},{"location":"","page":"Home","title":"Home","text":"x = rand(400,400)\ny = rand(400,400)\nzt = Dagger.@spawn x * y\nz = fetch(zt)\n@assert isapprox(z, x * y)","category":"page"},{"location":"","page":"Home","title":"Home","text":"One can also wait on the result of @spawn and check completion status with isready:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x = Dagger.@spawn sleep(10)\n@assert !isready(x)\nwait(x)\n@assert isready(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Like @async and Threads.@spawn, Dagger.@spawn synchronizes with locally-scoped @sync blocks:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function sleep_and_print(delay, str)\n    sleep(delay)\n    println(str)\nend\n@sync begin\n    Dagger.@spawn sleep_and_print(3, \"I print first\")\nend\nwait(Dagger.@spawn sleep_and_print(1, \"I print second\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"One can also safely call @spawn from another worker (not ID 1), and it will be executed correctly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x = fetch(Distributed.@spawnat 2 Dagger.@spawn 1+2) # fetches the result of `@spawnat`\nx::EagerThunk\n@assert fetch(x) == 3 # fetch the result of `@spawn`","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is useful for nested execution, where an @spawn'd thunk calls @spawn. This is detailed further in Dynamic Scheduler Control.","category":"page"},{"location":"#Errors","page":"Home","title":"Errors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If a thunk errors while running under the eager scheduler, it will be marked as having failed, all dependent (downstream) thunks will be marked as failed, and any future thunks that use a failed thunk as input will fail. Failure can be determined with fetch, which will re-throw the error that the originally-failing thunk threw. wait and isready will not check whether a thunk or its upstream failed; they only check if the thunk has completed, error or not.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This failure behavior is not the default for lazy scheduling (Lazy API), but can be enabled by setting the scheduler/thunk option (Scheduler and Thunk options) allow_error to true.  However, this option isn't terribly useful for non-dynamic usecases, since any thunk failure will propagate down to the output thunk regardless of where it occurs.","category":"page"},{"location":"#Lazy-API","page":"Home","title":"Lazy API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Alongside the modern eager API, Dagger also has a legacy lazy API, accessible via @par or delayed. The above computation can be executed with the lazy API by substituting @spawn with @par and fetch with collect:","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = @par add1(4)\nq = @par add2(p)\nr = @par add1(3)\ns = @par combine(p, q, r)\n\n@assert collect(s) == 16","category":"page"},{"location":"","page":"Home","title":"Home","text":"or similarly, in block form:","category":"page"},{"location":"","page":"Home","title":"Home","text":"s = @par begin\n    p = add1(4)\n    q = add2(p)\n    r = add1(3)\n    combine(p, q, r)\nend\n\n@assert collect(s) == 16","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, if you want to compute but not fetch the result of a lazy operation, you can call compute on the thunk. This will return a Chunk object which references the result (see Chunks for more details):","category":"page"},{"location":"","page":"Home","title":"Home","text":"x = @par 1+2\ncx = compute(x)\ncx::Chunk\n@assert collect(cx) == 3","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that, as a legacy API, usage of the lazy API is generally discouraged for modern usage of Dagger. The reasons for this are numerous:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Nothing useful is happening while the DAG is being constructed, adding extra latency\nDynamically expanding the DAG can't be done with @par and delayed, making recursive nesting annoying to write\nEach call to compute/collect starts a new scheduler, and destroys it at the end of the computation, wasting valuable time on setup and teardown\nDistinct schedulers don't share runtime metrics or learned parameters, thus causing the scheduler to act less intelligently\nDistinct schedulers can't share work or data directly","category":"page"},{"location":"#Chunks","page":"Home","title":"Chunks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dagger relies heavily on communication between workers to operate. To make this efficient when communicating potentially large units of data, Dagger uses a remote reference, called a Dagger.Chunk, to refer to objects which exist on another worker. Chunks are backed by a distributed refcounting mechanism provided by MemPool.jl, which ensures that the referenced data is not GC'd until all Chunks referencing that object are GC'd from all workers containing them. Conveniently, if you pass in a Chunk object as an input to a function using either API, then the thunk's payload function will get executed with the value contained in the Chunk. The scheduler also understands Chunks, and will try to schedule work close to where their Chunk inputs reside, to reduce communication overhead.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Chunks also have a cached type, a \"processor\", and a \"scope\", which are important for identifying the type of the object, where in memory (CPU RAM, GPU VRAM, etc.) the value resides, and where the value is allowed to be transferred and dereferenced. See Processors and Scopes for more details on how these properties can be used to control scheduling behavior around Chunks.","category":"page"},{"location":"#Scheduler-and-Thunk-options","page":"Home","title":"Scheduler and Thunk options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While Dagger generally \"just works\", sometimes one needs to exert some more fine-grained control over how the scheduler allocates work. There are two parallel mechanisms to achieve this: Scheduler options (from Dagger.Sch.SchedulerOptions) and Thunk options (from Dagger.Sch.ThunkOptions). These two options structs generally contain the same options, with the difference being that Scheduler options operate globally across an entire DAG, and Thunk options operate on a thunk-by-thunk basis. Scheduler options can be constructed and passed to collect() or compute() as the keyword argument options for lazy API usage:","category":"page"},{"location":"","page":"Home","title":"Home","text":"t = @par 1+2\nopts = Dagger.Sch.ThunkOptions(;single=1) # Execute on worker 1\n\ncompute(t; options=opts)\n\ncollect(t; options=opts)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thunk options can be passed to @spawn/spawn, @par, and delayed similarly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Execute on worker 1\n\nDagger.@spawn single=1 1+2\n\nDagger.spawn(+, 1, 2; single=1)\n\nopts = Dagger.Sch.ThunkOptions(;single=1)\ndelayed(+)(1, 2; options=opts)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dagger.Sch.SchedulerOptions Dagger.Sch.ThunkOptions","category":"page"}]
}
