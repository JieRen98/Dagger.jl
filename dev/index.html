<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Dagger.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Dagger.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li class="toplevel"><a class="tocitem" href="#DAG-creation-interface"><span>DAG creation interface</span></a></li><li><a class="tocitem" href="#Eager-Execution"><span>Eager Execution</span></a></li><li><a class="tocitem" href="#Scheduler-and-Thunk-options"><span>Scheduler and Thunk options</span></a></li><li><a class="tocitem" href="#Rough-high-level-description-of-scheduling"><span>Rough high level description of scheduling</span></a></li><li><a class="tocitem" href="#Modeling-of-Dagger-programs"><span>Modeling of Dagger programs</span></a></li></ul></li><li><a class="tocitem" href="processors/">Processors</a></li><li><a class="tocitem" href="checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="logging/">Logging and Graphing</a></li><li><a class="tocitem" href="benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="scheduler-internals/">Scheduler Internals</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="api/types/">Types</a></li><li><a class="tocitem" href="api/functions/">Functions and Macros</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-framework-for-out-of-core-and-parallel-execution"><a class="docs-heading-anchor" href="#A-framework-for-out-of-core-and-parallel-execution">A framework for out-of-core and parallel execution</a><a id="A-framework-for-out-of-core-and-parallel-execution-1"></a><a class="docs-heading-anchor-permalink" href="#A-framework-for-out-of-core-and-parallel-execution" title="Permalink"></a></h1><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>The main function for using Dagger is <code>delayed</code></p><p><code>delayed(f; options...)</code></p><p>It returns a function which when called creates a <code>Thunk</code> object representing a call to function <code>f</code> with the given arguments. If it is called with other thunks as input, then they form a graph with input nodes directed at the output. The function <code>f</code> gets the result of the input Thunks. Thunks don&#39;t pass keyword argument to the function <code>f</code>. Options kwargs... to <code>delayed</code> are passed to the scheduler to control its behavior:</p><ul><li><code>get_result::Bool</code> – return the actual result to the scheduler instead of <code>Chunk</code> objects. Used when <code>f</code> explicitly constructs a Chunk or when return value is small (e.g. in case of reduce)</li><li><code>meta::Bool</code> – pass the input “Chunk” objects themselves to <code>f</code> and not the value contained in them - this is always run on the master process</li><li><code>persist::Bool</code> – the result of this Thunk should not be released after it becomes unused in the DAG</li><li><code>cache::Bool</code> – cache the result of this Thunk such that if the thunk is evaluated again, one can just reuse the cached value. If it’s been removed from cache, recompute the value.</li></ul><h1 id="DAG-creation-interface"><a class="docs-heading-anchor" href="#DAG-creation-interface">DAG creation interface</a><a id="DAG-creation-interface-1"></a><a class="docs-heading-anchor-permalink" href="#DAG-creation-interface" title="Permalink"></a></h1><p>Here is a very simple example DAG:</p><pre><code class="language-julia hljs">using Dagger

add1(value) = value + 1
add2(value) = value + 2
combine(a...) = sum(a)

p = delayed(add1)(4)
q = delayed(add2)(p)
r = delayed(add1)(3)
s = delayed(combine)(p, q, r)

@assert collect(s) == 16</code></pre><p>The above computation can also be written in a more Julia-idiomatic syntax with <code>@par</code>:</p><pre><code class="language-julia hljs">p = @par add1(4)
q = @par add2(p)
r = @par add1(3)
s = @par combine(p, q, r)

@assert collect(s) == 16</code></pre><p>or similarly:</p><pre><code class="language-julia hljs">s = @par begin
    p = add1(4)
    q = add2(p)
    r = add1(3)
    combine(p, q, r)
end

@assert collect(s) == 16</code></pre><p>The connections between nodes <code>p</code>, <code>q</code>, <code>r</code> and <code>s</code> is represented by this dependency graph:</p><p><img src="https://user-images.githubusercontent.com/25916/26920104-7b9b5fa4-4c55-11e7-97fb-fe5b9e73cae6.png" alt="graph"/></p><p>The final result is the obvious consequence of the operation</p><p><code>add1(4)</code> + <code>add2(add1(4))</code> + <code>add1(3)</code></p><p><code>(4 + 1)</code> + <code>((4 + 1) + 2)</code> + <code>(3 + 1)</code> = 16</p><p>To compute and fetch the result of a thunk (say <code>s</code>), you can call <code>collect(s)</code>. <code>collect</code> will fetch the result of the computation to the master process. Alternatively, if you want to compute but not fetch the result you can call <code>compute</code> on the thunk. This will return a <code>Chunk</code> object which references the result. If you pass in a <code>Chunk</code> objects as an input to a delayed function, then the function will get executed with the value of the <code>Chunk</code> – this evaluation will likely happen where the input chunks are, to reduce communication.</p><p>The key point is that, for each argument to a node, if the argument is a <code>Thunk</code>, it&#39;ll be executed before this node and its result will be passed into the function <code>f</code> provided. If the argument is <em>not</em> a <code>Thunk</code> (just some regular Julia object), it&#39;ll be passed as-is to the function <code>f</code>.</p><h3 id="Polytree"><a class="docs-heading-anchor" href="#Polytree">Polytree</a><a id="Polytree-1"></a><a class="docs-heading-anchor-permalink" href="#Polytree" title="Permalink"></a></h3><p><a href="https://en.wikipedia.org/wiki/Polytree">Polytrees</a> are easily supported by Dagger. To make this work, pass all the head nodes <code>Thunk</code>s into a call to <code>delayed</code> as arguments, which will act as the top node for the graph.</p><pre><code class="language-julia hljs">group(x...) = [x...]
top_node = delayed(group)(head_nodes...)
compute(top_node)</code></pre><h2 id="Eager-Execution"><a class="docs-heading-anchor" href="#Eager-Execution">Eager Execution</a><a id="Eager-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Eager-Execution" title="Permalink"></a></h2><p>Similar to <code>@par</code>, Dagger has an <code>@spawn</code> macro (and matching <code>Dagger.spawn</code>) which works similarly to <code>@async</code> and <code>Threads.@spawn</code>: when called, it wraps the function call specified by the user in an <code>EagerThunk</code> object, and immediately places it onto a running scheduler, to be executed once its dependencies are fulfilled. This contrasts with <code>@par</code> in that <code>@par</code> does not begin executing its thunks until <code>collect</code> or <code>compute</code> are called on a given thunk or one of its downstream dependencies. Additionally, one fetches the result of any <code>@spawn</code> call with <code>fetch</code>. As a concrete example:</p><pre><code class="language-julia hljs">x = rand(400,400)
y = rand(400,400)
zt = Dagger.@spawn x * y
z = fetch(zt)</code></pre><p>One can also <code>wait</code> on the result of <code>@spawn</code> and check completion status with <code>isready</code>:</p><pre><code class="language-julia hljs">x = Dagger.@spawn sleep(10)
@assert !isready(x)
wait(x)
@assert isready(x)
@info &quot;Done!&quot;</code></pre><p>One can also safely call <code>@spawn</code> from another worker (not id 1), and it will be sent to worker 1 to schedule:</p><pre><code class="nohighlight hljs">x = fetch(Distributed.@spawnat 2 Dagger.@spawn 1+2) # actually scheduled on worker 1
x::EagerThunk
@assert fetch(x) == 3</code></pre><p>This is useful for nested execution, where an <code>@spawn</code>&#39;d thunk calls <code>@spawn</code>.</p><p>If a thunk errors while running under the eager scheduler, it will be marked as having failed, all dependent (downstream) thunks will be marked as failed, and any future thunks that use a failed thunk as input will fail. Failure can be determined with <code>fetch</code>, which will re-throw the error that the originally-failing thunk threw. <code>wait</code> and <code>isready</code> will <em>not</em> check whether a thunk or its upstream failed; they only check if the thunk has completed, error or not.</p><p>This failure behavior is not the default for lazy scheduling, but can be enabled by setting the scheduler/thunk option (see below) <code>allow_error</code> to <code>true</code>.  However, this option isn&#39;t terribly useful for non-dynamic usecases, since any thunk failure will propagate down to the output thunk regardless of where it occurs.</p><h2 id="Scheduler-and-Thunk-options"><a class="docs-heading-anchor" href="#Scheduler-and-Thunk-options">Scheduler and Thunk options</a><a id="Scheduler-and-Thunk-options-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduler-and-Thunk-options" title="Permalink"></a></h2><p>While Dagger generally &quot;just works&quot;, sometimes one needs to exert some more fine-grained control over how the scheduler allocates work. There are two parallel mechanisms to achieve this: Scheduler options (from <code>Dagger.Sch.SchedulerOptions</code>) and Thunk options (from <code>Dagger.Sch.ThunkOptions</code>). These two options structs generally contain the same options, with the difference being that Scheduler options operate globally across an entire DAG, and Thunk options operate on a thunk-by-thunk basis. Scheduler options can be constructed and passed to <code>collect()</code> or <code>compute()</code> as the keyword argument <code>options</code>, and Thunk options can be passed to Dagger&#39;s <code>delayed</code> function similarly: <code>delayed(myfunc)(arg1, arg2, ...; options=opts)</code>. Check the docstring for the two options structs to see what options are available.</p><h2 id="Rough-high-level-description-of-scheduling"><a class="docs-heading-anchor" href="#Rough-high-level-description-of-scheduling">Rough high level description of scheduling</a><a id="Rough-high-level-description-of-scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Rough-high-level-description-of-scheduling" title="Permalink"></a></h2><ul><li>First picks the leaf Thunks and distributes them to available workers. Each worker is given at most 1 task at a time. If input to the node is a <code>Chunk</code>, then workers which already have the chunk are preferred.</li><li>When a worker finishes a thunk it will return a <code>Chunk</code> object to the scheduler.</li><li>Once the worker has returned a <code>Chunk</code>, the scheduler picks the next task for the worker – this is usually the task the worker immediately made available (if possible). In the small example above, if worker 2 finished <code>p</code> it will be given <code>q</code> since it will already have the result of <code>p</code> which is input to <code>q</code>.</li><li>The scheduler also issues &quot;release&quot; Commands to chunks that are no longer required by nodes in the DAG: for example, when <code>s</code> is computed all of <code>p</code>, <code>q</code>, <code>r</code> are released to free up memory. This can be prevented by passing <code>persist</code> or <code>cache</code> options to <code>delayed</code>.</li></ul><h2 id="Modeling-of-Dagger-programs"><a class="docs-heading-anchor" href="#Modeling-of-Dagger-programs">Modeling of Dagger programs</a><a id="Modeling-of-Dagger-programs-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-of-Dagger-programs" title="Permalink"></a></h2><p>The key API for parallel and heterogeneous execution is <code>Dagger.delayed</code>. The call signature of <code>Dagger.delayed</code> is the following:</p><pre><code class="language-julia hljs">thunk = Dagger.delayed(func)(args...)</code></pre><p>This invocation serves to construct a single node in a computational graph. <code>func</code> is a Julia function, which normally takes some number of arguments, of length <code>N</code> and of types <code>Targs</code>. The set of arguments <code>args...</code> is specified with ellipses to indicate that many arguments may be passed between the parentheses. When correctly invoked, <code>args...</code> is of length <code>N</code> and of types <code>Targs</code> (or suitable subtypes of <code>Targs</code>, for each respective argument in <code>args...</code>).  <code>thunk</code> is an instance of a Dagger <code>Thunk</code>, which is the value used internally by Dagger to represent a node in the graph.</p><p>A <code>Thunk</code> may be &quot;computed&quot;:</p><pre><code class="language-julia hljs">chunk = Dagger.compute(thunk)</code></pre><p>Computing a <code>Thunk</code> performs roughly the same logic as the following Julia function invocation:</p><pre><code class="language-julia hljs">result = func(args...)</code></pre><p>Such an invocation invokes <code>func</code> on <code>args...</code>, returning <code>result</code>. Computing the above thunk would produce a value with the same type as <code>result</code>, with the caveat that the result will be wrapped by a <code>Dagger.Chunk</code> (<code>chunk</code> in the above example). A <code>Chunk</code> is a reference to a value stored on a compute process within the <code>Distributed</code> cluster that Dagger is operating within. A <code>Chunk</code> may be &quot;collected&quot;, which will return the wrapped value to the collecting process, which in the above example will be <code>result</code>:</p><pre><code class="language-julia hljs">result = collect(chunk)</code></pre><p>In order to create a graph with more than a single node, arguments to <code>delayed</code> may themselves be <code>Thunk</code>s or <code>Chunk</code>s. For example, the sum of the elements of vector <code>[1,2,3,4]</code> may be represented in Dagger as follows:</p><pre><code class="language-julia hljs">thunk1 = Dagger.delayed(+)(1, 2)
thunk2 = Dagger.delayed(+)(3, 4)
thunk3 = Dagger.delayed(+)(thunk1, thunk2)</code></pre><p>A graph has now been constructed, where <code>thunk1</code> and <code>thunk2</code> are dependencies (&quot;inputs&quot;) to <code>thunk3</code>. Computing <code>thunk3</code> and then collecting its resulting <code>Chunk</code> would result in the answer that is expected from the operation:</p><pre><code class="language-julia hljs">chunk = compute(thunk3)
result = collect(chunk)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; result == 10
true</code></pre><p><code>result</code> now has the <code>Int64</code> value <code>10</code>, which is the result of summing the elements of the vector <code>[1,2,3,4]</code>. For convenience, computation may be performed together with collection, like so:</p><pre><code class="language-julia hljs">result = collect(thunk3)</code></pre><p>The above summation example is equivalent to the following invocation in plain Julia:</p><pre><code class="language-julia hljs">x1 = 1 + 2
x2 = 3 + 4
result = x1 + x2
result == 10</code></pre><p>However, there are key differences when using Dagger to perform this operation as compared to performing this operation without Dagger. In Dagger, the graph is constructed separately from computing the graph (&quot;lazily&quot;), whereas without Dagger the graph is executed immediately (&quot;eagerly&quot;). Dagger makes use of this lazy construction approach to allow modifying the actual execution of the overall operation in useful ways.</p><p>By default, computing a Dagger graph creates an instance of a scheduler, which will be provided the graph to execute. The scheduler executes the individual nodes of the graph on their arguments in the order specified by the graph (ensuring dependencies to a node are satisfied before executing said node) on compute processes in the cluster; the scheduler process itself typically does not execute the nodes directly. Additionally, if a given set of nodes do not depend on each other (the value generated by a node is not an input to another node in the set), then those nodes may be executed in parallel, and the scheduler attempts to schedule such nodes in parallel when possible.</p><p>The scheduler also orchestrates data movement between compute processes, such that inputs to a given node are available on the compute process that is scheduled to execute said node. The scheduler attempts to minimize data movement between compute processes; it does so by trying to schedule nodes which depend on a given input on the same compute process that computed and retains that input.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="processors/">Processors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.4 on <span class="colophon-date" title="Monday 26 July 2021 18:26">Monday 26 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
