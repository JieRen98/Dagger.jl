<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Dagger.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Dagger.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Chunks"><span>Chunks</span></a></li></ul></li><li><a class="tocitem" href="dtable/">Distributed Table</a></li><li><a class="tocitem" href="processors/">Processors</a></li><li><a class="tocitem" href="scopes/">Scopes</a></li><li><a class="tocitem" href="mutation/">Mutation and Shards</a></li><li><a class="tocitem" href="dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="propagation/">Option Propagation</a></li><li><a class="tocitem" href="logging/">Logging and Graphing</a></li><li><a class="tocitem" href="scheduler-visualization/">Scheduler Visualization</a></li><li><a class="tocitem" href="benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="checkpointing/">Checkpointing</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="api/types/">Types</a></li><li><a class="tocitem" href="api/functions/">Functions and Macros</a></li></ul></li><li><a class="tocitem" href="scheduler-internals/">Scheduler Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-framework-for-out-of-core-and-parallel-execution"><a class="docs-heading-anchor" href="#A-framework-for-out-of-core-and-parallel-execution">A framework for out-of-core and parallel execution</a><a id="A-framework-for-out-of-core-and-parallel-execution-1"></a><a class="docs-heading-anchor-permalink" href="#A-framework-for-out-of-core-and-parallel-execution" title="Permalink"></a></h1><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>The main function for using Dagger is <code>spawn</code>:</p><p><code>Dagger.spawn(f, args...; options...)</code></p><p>or <code>@spawn</code> for the more convenient macro form:</p><p><code>Dagger.@spawn [option=value]... f(args...)</code></p><p>When called, it creates an <code>EagerThunk</code> (also known as a &quot;thunk&quot; or &quot;task&quot;) object representing a call to function <code>f</code> with the arguments <code>args</code>. If it is called with other thunks as inputs, such as in <code>Dagger.@spawn f(Dagger.@spawn g())</code>, then the function <code>f</code> gets passed the results of those input thunks. If those thunks aren&#39;t yet finished executing, then the execution of <code>f</code> waits on all of its input thunks to complete before executing.</p><p>The key point is that, for each argument to a thunk, if the argument is an <code>EagerThunk</code>, it&#39;ll be executed before this node and its result will be passed into the function <code>f</code>. If the argument is <em>not</em> an <code>EagerThunk</code> (instead, some other type of Julia object), it&#39;ll be passed as-is to the function <code>f</code>.</p><p>Thunks don&#39;t accept regular keyword arguments for the function <code>f</code>. Instead, the <code>options</code> kwargs are passed to the scheduler to control its behavior:</p><ul><li>Any field in <code>Dagger.Sch.ThunkOptions</code> (see <a href="#Scheduler-and-Thunk-options">Scheduler and Thunk options</a>)</li><li><code>meta::Bool</code> – Pass the input <code>Chunk</code> objects themselves to <code>f</code> and not the value contained in them</li></ul><p>There are also some extra kwargs that can be passed, although they&#39;re considered advanced options to be used only by developers or library authors:</p><ul><li><code>get_result::Bool</code> – return the actual result to the scheduler instead of <code>Chunk</code> objects. Used when <code>f</code> explicitly constructs a Chunk or when return value is small (e.g. in case of reduce)</li><li><code>persist::Bool</code> – the result of this Thunk should not be released after it becomes unused in the DAG</li><li><code>cache::Bool</code> – cache the result of this Thunk such that if the thunk is evaluated again, one can just reuse the cached value. If it’s been removed from cache, recompute the value.</li></ul><h3 id="Simple-example"><a class="docs-heading-anchor" href="#Simple-example">Simple example</a><a id="Simple-example-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-example" title="Permalink"></a></h3><p>Let&#39;s see a very simple directed acyclic graph (or DAG) constructed with Dagger:</p><pre><code class="language-julia hljs">using Dagger

add1(value) = value + 1
add2(value) = value + 2
combine(a...) = sum(a)

p = Dagger.@spawn add1(4)
q = Dagger.@spawn add2(p)
r = Dagger.@spawn add1(3)
s = Dagger.@spawn combine(p, q, r)

@assert fetch(s) == 16</code></pre><p>The thunks <code>p</code>, <code>q</code>, <code>r</code>, and <code>s</code> have the following structure:</p><p><img src="https://user-images.githubusercontent.com/25916/26920104-7b9b5fa4-4c55-11e7-97fb-fe5b9e73cae6.png" alt="graph"/></p><p>The final result (from <code>fetch(s)</code>) is the obvious consequence of the operation:</p><p><code>add1(4) + add2(add1(4)) + add1(3)</code></p><p><code>(4 + 1) + ((4 + 1) + 2) + (3 + 1) == 16</code></p><h3 id="Eager-Execution"><a class="docs-heading-anchor" href="#Eager-Execution">Eager Execution</a><a id="Eager-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Eager-Execution" title="Permalink"></a></h3><p>Dagger&#39;s <code>@spawn</code> macro works similarly to <code>@async</code> and <code>Threads.@spawn</code>: when called, it wraps the function call specified by the user in an <code>EagerThunk</code> object, and immediately places it onto a running scheduler, to be executed once its dependencies are fulfilled.</p><pre><code class="language-julia hljs">x = rand(400,400)
y = rand(400,400)
zt = Dagger.@spawn x * y
z = fetch(zt)
@assert isapprox(z, x * y)</code></pre><p>One can also <code>wait</code> on the result of <code>@spawn</code> and check completion status with <code>isready</code>:</p><pre><code class="language-julia hljs">x = Dagger.@spawn sleep(10)
@assert !isready(x)
wait(x)
@assert isready(x)</code></pre><p>One can also safely call <code>@spawn</code> from another worker (not ID 1), and it will be executed correctly:</p><pre><code class="nohighlight hljs">x = fetch(Distributed.@spawnat 2 Dagger.@spawn 1+2) # fetches the result of `@spawnat`
x::EagerThunk
@assert fetch(x) == 3 # fetch the result of `@spawn`</code></pre><p>This is useful for nested execution, where an <code>@spawn</code>&#39;d thunk calls <code>@spawn</code>. This is detailed further in <a href="dynamic/#Dynamic-Scheduler-Control">Dynamic Scheduler Control</a>.</p><h3 id="Errors"><a class="docs-heading-anchor" href="#Errors">Errors</a><a id="Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Errors" title="Permalink"></a></h3><p>If a thunk errors while running under the eager scheduler, it will be marked as having failed, all dependent (downstream) thunks will be marked as failed, and any future thunks that use a failed thunk as input will fail. Failure can be determined with <code>fetch</code>, which will re-throw the error that the originally-failing thunk threw. <code>wait</code> and <code>isready</code> will <em>not</em> check whether a thunk or its upstream failed; they only check if the thunk has completed, error or not.</p><p>This failure behavior is not the default for lazy scheduling (<a href="#Lazy-API">Lazy API</a>), but can be enabled by setting the scheduler/thunk option (<a href="#Scheduler-and-Thunk-options">Scheduler and Thunk options</a>) <code>allow_error</code> to <code>true</code>.  However, this option isn&#39;t terribly useful for non-dynamic usecases, since any thunk failure will propagate down to the output thunk regardless of where it occurs.</p><h3 id="Lazy-API"><a class="docs-heading-anchor" href="#Lazy-API">Lazy API</a><a id="Lazy-API-1"></a><a class="docs-heading-anchor-permalink" href="#Lazy-API" title="Permalink"></a></h3><p>Alongside the modern eager API, Dagger also has a legacy lazy API, accessible via <code>@par</code> or <code>delayed</code>. The above computation can be executed with the lazy API by substituting <code>@spawn</code> with <code>@par</code> and <code>fetch</code> with <code>collect</code>:</p><pre><code class="language-julia hljs">p = @par add1(4)
q = @par add2(p)
r = @par add1(3)
s = @par combine(p, q, r)

@assert collect(s) == 16</code></pre><p>or similarly, in block form:</p><pre><code class="language-julia hljs">s = @par begin
    p = add1(4)
    q = add2(p)
    r = add1(3)
    combine(p, q, r)
end

@assert collect(s) == 16</code></pre><p>Alternatively, if you want to compute but not fetch the result of a lazy operation, you can call <code>compute</code> on the thunk. This will return a <code>Chunk</code> object which references the result (see <a href="#Chunks">Chunks</a> for more details):</p><pre><code class="language-julia hljs">x = @par 1+2
cx = compute(x)
cx::Chunk
@assert collect(cx) == 3</code></pre><p>Note that, as a legacy API, usage of the lazy API is generally discouraged for modern usage of Dagger. The reasons for this are numerous:</p><ul><li>Nothing useful is happening while the DAG is being constructed, adding extra latency</li><li>Dynamically expanding the DAG can&#39;t be done with <code>@par</code> and <code>delayed</code>, making recursive nesting annoying to write</li><li>Each call to <code>compute</code>/<code>collect</code> starts a new scheduler, and destroys it at the end of the computation, wasting valuable time on setup and teardown</li><li>Distinct schedulers don&#39;t share runtime metrics or learned parameters, thus causing the scheduler to act less intelligently</li><li>Distinct schedulers can&#39;t share work or data directly</li></ul><h2 id="Chunks"><a class="docs-heading-anchor" href="#Chunks">Chunks</a><a id="Chunks-1"></a><a class="docs-heading-anchor-permalink" href="#Chunks" title="Permalink"></a></h2><p>Dagger relies heavily on communication between workers to operate. To make this efficient when communicating potentially large units of data, Dagger uses a remote reference, called a <code>Dagger.Chunk</code>, to refer to objects which exist on another worker. <code>Chunk</code>s are backed by a distributed refcounting mechanism provided by MemPool.jl, which ensures that the referenced data is not GC&#39;d until all <code>Chunk</code>s referencing that object are GC&#39;d from all workers containing them. Conveniently, if you pass in a <code>Chunk</code> object as an input to a function using either API, then the thunk&#39;s payload function will get executed with the value contained in the <code>Chunk</code>. The scheduler also understands <code>Chunk</code>s, and will try to schedule work close to where their <code>Chunk</code> inputs reside, to reduce communication overhead.</p><p><code>Chunk</code>s also have a cached type, a &quot;processor&quot;, and a &quot;scope&quot;, which are important for identifying the type of the object, where in memory (CPU RAM, GPU VRAM, etc.) the value resides, and where the value is allowed to be transferred and dereferenced. See <a href="processors/#Processors">Processors</a> and <a href="scopes/#Scopes">Scopes</a> for more details on how these properties can be used to control scheduling behavior around <code>Chunk</code>s.</p><h3 id="Scheduler-and-Thunk-options"><a class="docs-heading-anchor" href="#Scheduler-and-Thunk-options">Scheduler and Thunk options</a><a id="Scheduler-and-Thunk-options-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduler-and-Thunk-options" title="Permalink"></a></h3><p>While Dagger generally &quot;just works&quot;, sometimes one needs to exert some more fine-grained control over how the scheduler allocates work. There are two parallel mechanisms to achieve this: Scheduler options (from <code>Dagger.Sch.SchedulerOptions</code>) and Thunk options (from <code>Dagger.Sch.ThunkOptions</code>). These two options structs generally contain the same options, with the difference being that Scheduler options operate globally across an entire DAG, and Thunk options operate on a thunk-by-thunk basis. Scheduler options can be constructed and passed to <code>collect()</code> or <code>compute()</code> as the keyword argument <code>options</code> for lazy API usage:</p><pre><code class="language-julia hljs">t = @par 1+2
opts = Dagger.Sch.ThunkOptions(;single=1) # Execute on worker 1

compute(t; options=opts)

collect(t; options=opts)</code></pre><p>Thunk options can be passed to <code>@spawn/spawn</code>, <code>@par</code>, and <code>delayed</code> similarly:</p><pre><code class="language-julia hljs"># Execute on worker 1

Dagger.@spawn single=1 1+2

Dagger.spawn(+, 1, 2; single=1)

opts = Dagger.Sch.ThunkOptions(;single=1)
delayed(+)(1, 2; options=opts)</code></pre><p><a href="api/types/#Dagger.Sch.SchedulerOptions"><code>Dagger.Sch.SchedulerOptions</code></a> <a href="api/types/#Dagger.Sch.ThunkOptions"><code>Dagger.Sch.ThunkOptions</code></a></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="dtable/">Distributed Table »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 1 February 2022 21:03">Tuesday 1 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
